{"file_path": "/Users/allwefantasy/projects/llm_friendly_packages/github.com/allwefantasy/.DS_Store", "relative_path": ".DS_Store", "content": [], "modify_time": 1723806443.7076888}
{"file_path": "/Users/allwefantasy/projects/llm_friendly_packages/github.com/allwefantasy/byzer-sql/README.md", "relative_path": "byzer-sql/README.md", "content": [{"module_name": "##File: /Users/allwefantasy/projects/llm_friendly_packages/github.com/allwefantasy/byzer-sql/README.md", "source_code": "# Byzer-SQL 快速入门文档\n\n## 数据加载/Load\n\nByzer-Lang 的设计理念是 `Everything is a table`，在 Byzer-Lang 中所有的文件都可以被抽象成表的概念。\n\n多样的数据源例如：数据库，数据仓库，数据湖甚至是 Rest API 都可以被 Byzer-lang 抽象成二维表的方式读入并进行后续的分析处理，而读入数据源的这一重要过程主要通过 `load` 句式来达成。\n\n### 1. 基本语法\n\n先来看一个最简单的 load 语句：\n\n```sql\nset abc='''\n{ \"x\": 100, \"y\": 200, \"z\": 200 ,\"dataType\":\"A group\"}\n{ \"x\": 120, \"y\": 100, \"z\": 260 ,\"dataType\":\"B group\"}\n''';\nload jsonStr.`abc` as table1;\n```\n\n在这个示例中，设置了一个变量，变量名称是 `abc`， 通过 `jsonStr` 数据源，使用 `load` 语句将这段文本注册成一张视图（表）。\n\n\n**我们来解析一下该句中的语法含义和需要注意的关键点：**\n\n```sql\nload jsonStr.`abc` as table1;\n```\n\n- 第一个关键点是 `load`，代表读入数据源的行为\n- 第二个关键点是 `jsonStr` ，这里代表的是数据源或者格式名称，该句表示这里加载的是一个 json 的字符串，\n- 第三个关键点是 `.` 和 `abc` ， 通常反引号内是个路径，比如:\n\n```\ncsv.`/tmp/csvfile`\n```\n\n- 第四个关键点：为了方便引用加载的结果表，我们需要使用 `as` 句式，将结果存为一张新表，这里我们取名为 `table1`。`table1` 可以被后续的 `select` 句式引用，例如：\n\n```sql\nset abc='''\n{ \"x\": 100, \"y\": 200, \"z\": 200 ,\"dataType\":\"A group\"}\n{ \"x\": 120, \"y\": 100, \"z\": 260 ,\"dataType\":\"B group\"}\n''';\nload jsonStr.`abc` as table1;\nselect * from table1 as output;\n```\n\n### 2. 如何获取可用数据源\n\n1）既然 `load` 句式是用来获取数据源的，用户如何知道当前实例中支持的数据源（例如上述的 jsonStr） 有哪些呢？\n\n可以通过如下指令来查看当前实例支持的数据源（内置或者通过插件安装的）：\n\n```sql\n!show datasources;\n```\n\n输出如下：\n\n```\nrate\nstreamJDBC\ncustom\nmodel\njsonStr\nimage\njdbc\nparquet\nlibsvm\nxml\nmodel2\nhive\ncarbondata\ndelta\nes\nstreamParquet\nwebConsole\nredis\nkafka9\nscript\nbinaryFile\nhbase\nbinlog\nmongo\nconsole\nEverything\nsolr\nparquet\ncsv\njsonStr\ncsvStr\njson\ntext\norc\nkafka\nkafka8\nkafka9\ncrawlersql\nimage\nscript\nhive\nxml\nmlsqlAPI\nmlsqlConf\n```\n\n2）用户如果想知道某个数据源是否支持该怎么做？\n\n可以通过 **模糊匹配** 来定位某个数据源是否支持。\n\n例如，我们想要知道是否支持读取 `csvStr`：\n\n```sql\n!show datasources;\n!lastCommand named datasources;\nselect * from datasources where name like \"%csv%\" as output;\n```\n\n3）当用户想知道数据源对应的一些参数时该如何查看？\n\n可以通过如下命令查看，例如这里我们想要知道 `csv` 支持的相关参数：\n\n```sql\n!show datasources/params/csv;\n```\n\n### 3. Load 和 Connect 句式的配合使用\n\n`load` 支持 `connect` 语句的引用。\n\n比如：\n\n```sql\nconnect jdbc where\nurl=\"jdbc:mysql://127.0.0.1:3306/wow?characterEncoding=utf8&zeroDateTimeBehavior=convertToNull&tinyInt1isBit=false\"\nand driver=\"com.mysql.jdbc.Driver\"\nand user=\"xxxxx\"\nand password=\"xxxxx\"\nas db_1;\n\nload jdbc.`db_1.<TABLE_NAME>` as output;\n```\n\n在这个例子中，我们通过`connect` 语句去连接了一个 jdbc 数据源，再通过 Load 语句读取该数据源中对应的库表。\n\n此处`connect` 语句并不是真的去连接数据库，而仅仅是方便后续记在同一数据源，避免在 `load/save` 句式中反复填写相同的参数。\n\n对于示例中的 `connect` 语句， jdbc + db_1 为唯一标记。 当系统遇到下面 `load` 语句中jdbc.`db_1.<TABLE_NAME>` 时，他会通过 jdbc 以及 db_1 找到所有的配置参数， 如 driver， user, url, 等等，然后自动附带上到 `load` 语句中。\n\n\n\n### 4. 直接查询模式(DirectQuery)\n\n有部分数据源支持直接查询模式，目前官方内置了 JDBC 数据源直接查询模式的支持。\n\n示例：\n\n```sql\nconnect jdbc where\n url=\"jdbc:mysql://127.0.0.1:3306/wow?characterEncoding=utf8&zeroDateTimeBehavior=convertToNull&tinyInt1isBit=false\"\n and driver=\"com.mysql.jdbc.Driver\"\n and user=\"xxxx\"\n and password=\"xxxx\"\n as mysql_instance;\n\nload jdbc.`mysql_instance.<TABLE_NAME>` where directQuery='''\nselect * from <TABLE_NAME> limit 10\n''' as newtable;\n\nselect * from newtable as output;\n```\n\n在 JDBC 数据源的 `where/options` 参数里，用户可以配置一个 `directQuery` 参数。\n该参数可以写数据源原生支持的语法。比如对于 ClickHouse 可能就是一段合乎 ClickHouse 用法的 SQL, 而对于 MySQL 则可能是合乎 MySQL 语法的 SQL。\n\nByzer-lang 会将 `directQuery` 的查询下推到底层引擎，并且将执行的结果作为注册成新的表。 \n在上面的例子中，新表名称为 `newtable`。 这个表可以被后续的 Byzer-lang 代码引用。\n\n\n## 数据转换/Select\n\n`select` 句式是 Byzer-lang 中处理数据最重要的方式之一。\n\n> Byzer-lang 中的 `select` 句式除了最后 `as 表名` 以外，完全兼容 Spark SQL。\n> 一般来讲，可以结合使用 Spark SQL 中的函数和算子以及 Byzer 的一些特定语法命令或 UDF 来完成数据转换的功能\n\n### 1. 基本语法\n\n最简单的一个 `select` 语句：\n\n```sql\nselect 1 as col1 \nas table1;\n```\n\n结果为：col1: 1。\n\n从上面代码可以看到，Byzer-lang 中的 `select` 语法和传统 SQL `select` 语法唯一的差别就是后面多了一个 `as tableName`。\n这也是为了方便后续对该 SQL 处理的结果进行引用引入的微小改良。\n\n**正常的 SQL 语句：**\n\n```sql\nSELECT\nb.* \nFROM\n table_a as a\n LEFT JOIN table_b as b \n ON a.id = b.id \nWHERE\n a.study_id in( '12345678' )\n AND a.status <> 3 \n AND b.use_status = 0；\n```\n\n**Byzer 语法：**\n\n```sql\nSELECT\nb.* \nFROM\n table_a as a\n LEFT JOIN table_b as b \n ON a.id = b.id \nWHERE\n a.study_id in( '12345678' )\n AND a.status <> 3 \n AND b.use_status = 0 as new_table;\n \n select * from new_table as traindata;\n```\n\n比如，对于 `new_table`, 用户可以在新的 `select` 语句中进行引用：\n\n### 2. Select 句式中的模板功能\n\n实际在书写 `select` 语句可能会非常冗长。Byzer-lang 提供了两种方法帮助大家简化代码。\n\n对于如下代码示例：\n\n```sql\nselect \"\" as features, 1 as label as mockData;\n\nselect \nSUM( case when features is null or features='' then 1 else 0 end ) as features,\nSUM( case when label is null or label='' then 1 else 0 end ) as label,\n1 as a from mockData as output;\n```\n\n如果字段特别多，而且都要做类似的事情，可能要写非常多的 SUM 语句。\n\n用户可以通过如下语法进行改进：\n\n```sql\nselect \"\" as features, 1 as label as mockData;\n\nselect \n#set($colums=[\"features\",\"label\"])\n#foreach( $column in $colums )\n    SUM( case when `$column` is null or `$column`='' then 1 else 0 end ) as $column,\n#end\n 1 as a from mockData as output;\n```\n\n`#set` 设置了一个模板变量 `$columns`, 然后使用 `#foreach` 对该变量进行循环，里面的 SUM 本质上成了一个模板。\n系统在执行该 `select` 语句的时候，会自动根据这些指令展开成类似前面手写的代码。\n\nByzer-lang 还提供了一个更加易用的模板方案：\n\n```sql\n set sum_tpl = '''\nSUM( case when `{0}` is null or `{0}`='' then 1 else 0 end ) as {0}\n''';\n\nselect ${template.get(\"sum_tpl\",\"label\")},\n${template.get(\"sum_tpl\",\"label\")}\nfrom mockData as output;\n```\n\n通过变量声明设置一个模板，该模板通过名为 `sum_tpl` 变量持有，并且支持位置参数。接着，在 `select` 句式中使用 `${template.get}` 对模板进行渲染了。\n第一个参数是模板名，后面的参数则是模板的参数。\n\nByzer SQL 脚本也有作用域的概念。作用域是指变量的生命周期。\n\n## 变量设置/Set\n\nByzer-lang 支持变量的设置和复用。\n\n### 1. 基础应用\n\n```sql\nset hello=\"world\";\n```\n\n此时用户运行后不会有任何输出结果。\n\n如果希望看到此变量，可以通过 `select` 语句进行查看。\n\n示例：\n\n```sql\n\nset hello=\"world\";\n\nselect \"hello ${hello}\" as title \nas output;\n```\n\n得到结果如下：\n\n\n|title|\n|----|\n|hello world|\n\n通常， 变量可以用于任何语句的任何部分。甚至可以是结果输出表名，比如下面的例子\n\n\n```sql\n\nset hello=\"world\";\n\nselect \"hello William\" as title \nas `${hello}`;\n\nselect * from world as output;\n```\n\n结果如下：\n\n| title         |\n| ------------- |\n| hello William |\n\n在上面代码中，并没有显式的定义 `world` 表，但用户依然可以在 `select` 语句中使用 `world` 表。\n\n> 表名需要使用反引号将其括起来，避免语法解析错误\n\n\n\n#### 生命周期\n\n值得一提的是，`set` 语法当前的生命周期是 `request` 级别的，也就是每次请求有效。\n\n通常在 Byzer-lang 中，生命周期分成三个部分：\n\n1. request （当前执行请求有效/ Notebook 中实现为 Cell 等级）\n2. session  （当前会话周期有效 /Notebook 的用户等级）\n3. application （全局应用有效，暂不支持）\n\n\n`request` 级别表示什么含义呢？ 如果你先执行\n\n```sql\nset hello=\"world\";\n```\n\n然后再单独执行\n\n```sql\nselect \"hello William\" as title \nas `${hello}`;\n\nselect * from world as output;\n```\n\n系统会提示报错：\n\n```\nIllegal repetition near index 17\n((?i)as)[\\s|\\n]+`${hello}`\n                 ^\njava.util.regex.PatternSyntaxException: Illegal repetition near index 17\n((?i)as)[\\s|\\n]+`${hello}`\n                 ^\njava.util.regex.Pattern.error(Pattern.java:1955)\njava.util.regex.Pattern.closure(Pattern.java:3157)\njava.util.regex.Pattern.sequence(Pattern.java:2134)\njava.util.regex.Pattern.expr(Pattern.java:1996)\njava.util.regex.Pattern.compile(Pattern.java:1696)\njava.util.regex.Pattern.<init>(Pattern.java:1351)\njava.util.regex.Pattern.compile(Pattern.java:1028)\njava.lang.String.replaceAll(String.java:2223)\ntech.mlsql.dsl.adaptor.SelectAdaptor.analyze(SelectAdaptor.scala:49)\n```\n\n系统找不到 ${hello} 这个变量,然后原样输出，最后导致语法解析错误。\n\n如果你希望变量可以跨 cell ( Notebook中 )使用，可以通过如下方式来设置。\n\n```sql\nset hello=\"abc\" where scope=\"session\";\n```\n\n变量默认生命周期是 `request`。 也就是当前脚本或者当前 cell 中有效。 \n\n\n### 2. 变量类型\n\nByzer-lang 的变量被分为五种类型：\n\n1. `text`\n2. `conf`\n3. `shell`\n4. `sql`\n5. `defaultParam`\n\n- 第一种 `text`， 前面演示的代码大部分都是这种变量类型。\n\n示例：\n\n```sql\nset hello=\"world\";\n```\n\n\n\n- 第二种 `conf` 表示这是一个配置选项，通常用于配置系统的行为，比如：\n\n```sql\nset spark.sql.shuffle.partitions=200 where type=\"conf\";\n```\n\n该变量表示将底层 Spark 引擎的 shuffle 默认分区数设置为 200。 \n\n\n\n- 第三种是 `shell`，也就是 `set` 后的 key 最后是由 shell 执行生成的。 \n\n> 不推荐使用该方式， 安全风险较大\n\n典型的例子比如：\n\n```sql\nset date=`date` where type=\"shell\";\nselect \"${date}\" as dt as output;\n```\n注意：这里需要使用反引号括住该命令。\n\n输出结果为：\n\n|dt|\n|----|\n|`Mon Aug 19 10:28:10 CST 2019`|\n\n\n\n- 第四种是 `sql` 类型，这意味着 `set` 后的 key 最后是由 sql 引擎执行生成的。下面的例子可以看出其特点和用法：\n\n```sql\nset date=`select date_sub(CAST(current_timestamp() as DATE), 1) as dt` \nwhere type=\"sql\";\n\nselect \"${date}\" as dt as output;\n```\n\n注意这里也需要使用反引号括住命令。 最后结果输出为：\n\n|dt|\n|----|\n|2019-08-18|\n\n\n\n- 最后一种是 `defaultParam`。\n\n示例：\n\n```sql\nset hello=\"foo\";\nset hello=\"bar\";\n\nselect \"${hello}\" as name as output;\n```\n\n结果输出是：\n\n| name |\n| ---- |\n| bar  |\n\n上述代码中后面的`\"bar\"` 会覆盖前面的 `\"foo\"`。而 Byzer-lang 引入了 `defaultParam` 类型的变量来达到一种效果：如果变量已经设置了，新变量声明就失效，如果变量没有被设置过，则生效。 \n\n```sql\nset hello=\"foo\";\nset hello=\"bar\" where type=\"defaultParam\";\n\nselect \"${hello}\" as name as output;\n```\n\n最后输出结果是：\n\n| name |\n| ---- |\n| foo  |\n\n如果前面没有设置过 `hello=\"foo\"`,\n\n\n```sql\nset hello=\"bar\" where type=\"defaultParam\";\n\nselect \"${hello}\" as name as output;\n```\n\n则输出结果为：\n\n| name |\n| ---- |\n| bar  |\n\n\n\n### 3. 编译时和运行时变量\n\nByzer-lang 有非常完善的权限体系，可以轻松控制任何数据源到列级别的访问权限，而且创新性的提出了预处理时权限，\n也就是通过静态分析 Byzer-lang 脚本从而完成表级别权限的校验（列级别依然需要运行时完成）。\n\n但是预处理期间，权限最大的挑战在于 `set` 变量的解析，比如：\n\n```sql\nselect \"foo\" as foo as foo_table;\nset hello=`select foo from foo_table` where type=\"sql\";\nselect \"${hello}\" as name as output; \n```\n\n在没有执行第一个句子，那么第二条 `set` 语句在预处理期间执行就会报错，因为此时并没有叫 `foo_table` 的表。\n\n为了解决这个问题，Byzer-lang 引入了 `compile/runtime` 两个模式。如果用户希望在 `set` 语句预处理阶段就可以 evaluate 值，那么添加该参数即可。\n\n```sql\nset hello=`select 1 as foo ` where type=\"sql\" and mode=\"compile\";\n```\n\n如果希望 `set` 变量，只在运行时才需要执行，则设置为 `runtime`:\n\n```sql\nset hello=`select 1 as foo ` where type=\"sql\" and mode=\"runtime\";\n```\n\n此时，Byzer-lang 在预处理阶段不会进行该变量的创建。\n\n\n### 4. 内置变量\n\nByzer-lang 提供了一些内置变量，看下面的代码：\n\n```sql\nset jack='''\n hello today is:${date.toString(\"yyyyMMdd\")}\n''';\n```\n\n`date` 是内置的，你可以用他实现丰富的日期处理。\n\n1. 临时表，比如 `select 1 as number as tempTable;` 这个 tempTable 就是一个临时表。默认是用户级别的作用域。\n2. set 语法变量，比如 `set a=1;` 这个 a 就是一个变量。变量可以手动设置作用域。比如 `set a=1 where scope=\"session\";` 这个 a 就是一个 用户级别的 作用域的变量。默认是 request 级别，也就是单次和引擎的交互中有效。\n3. 分支条件语句里. 比如 `if \":number > 10\" ;` 这种可以引用外部的 set 变量，但是只在分支条件语句里有效。\n4. connect 语句中的连接名称。他是 applicaiton 级别的。所有用户都可以使用。\n\n### 作用域\n\nByzer SQL 中的作用域分成三种：\n\n1. request 级别，也就是单次和引擎的交互中有效。\n2. session/user 级别，也就是用户级别的作用域。比如用户登录后，可以在 session 级别的作用域里设置变量，这个变量在用户的整个会话中有效。\n3. application 级别，也就是应用级别的作用域。比如在应用启动后，可以在 application 级别的作用域里设置变量，这个变量在应用的整个生命周期中有效。\n\n\n#### request 级别作用域\n\n前面我们看到， 目前只有 `set` 一个变量，这个变量的作用域默认就是 request 级别的。也就是说，这个变量只在当前的请求中有效。\n\n你可以通过 `set a=1 where scope=\"request\";` 来显式的设置一个变量的作用域为 request 级别。为了能够跨 Cell/Notebook 有效，你可以在 `set` 语句中加入 `where scope=\"session\"` 来改成 session/user 级别的作用域。\n\n#### session/user 级别作用域\n\n这个作用域最主要就是为了方便在 Byzer Notebook 中调试。比如你在一个 Notebook 中设置了一个变量，你希望在另外一个 Notebook 中也能够使用这个变量，那么你就可以在 `set` 语句中加入 `where scope=\"session\"` 来改成 session/user 级别的作用域。\n\n或者你在一个 Notebook 得到一个表，在另外一个 Notebook 中继续使用这个表，方便调试和使用。\n\n> 注意： Byzer Notebook 和 Jupyter 不一样， Byzer Notebook 的不同的 Notebook 默认是共享一个 Byzer 引擎实例的，所以同一个用户的不同 Notebook 之间是可以共享变量的。\n\n#### 常见问题\n\n1. 假设我写了两个脚本，A，B ，现在我同时提交了 A，B 到引擎，此时会导致 A,B 之间的变量互相冲突，导致结果异常。\n\n分析： 因为表名是 session/user 级别作用域的。只要是以同一个账户提交的，那么不同脚本之间是可以互相看到对方变量的。这个时候因为执行顺序问题，会发生变量互相覆盖的问题，导致结果异常。为了解决这个问题，可以在提交的时候，同时设置两个HTTP请求参数：\n\n1. sessionPerUser=true\n2. sessionPerRequest=true\n\n第一个是默认的，就是每个用户是绑定一个session的，第二个设置为true，表示在 session/user 隔离的基础上，每次请求，都复制一个session出来，不同副本之间就毫无关系了，这样就可以避免不同脚本之间的变量互相冲突的问题。\n\n2. 如果我写了很多脚本，放到调度系统里去，脚本之间互相有依赖，是不是可以利用同一个用户的 session/user 级别作用域来实现数据表之间的呢？\n\n答案是不推荐。如果你开启了  `sessionPerRequest=true`, 那么这种依赖就会失效。 如果你没有开启，复杂的依赖里，会有脚本并行执行的可能性，导致前面我们提到的异常。并且还会产生一个比较大的问题，在 A 脚本中设置了一个变量，在B 脚本中没有重置，会导致这个变量影响到了 B 脚本。\n\n所以，如果你的脚本是有依赖的，那么你可以保证脚本的独立性，脚本和脚本之间通过持久化存储来完成衔接。\n\n## 数据保存/Save\n\n`save` 句式类似传统 SQL 中的 `insert` 语法。但同 `load` 语法一样，Byzer-lang 是要面向各种数据源的，譬如各种对象存储，亦或是各种类型的库表，不仅仅局限在数仓。`insert` 语法无法很好的满足该诉求，\n同时 `insert` 语法过于繁琐，所以 Byzer-lang 提供了新的 `save` 句式专门应对数据存储。\n\n### 1. 基本语法\n\n```sql\nset rawData='''\n  {\"jack\":1,\"jack2\":2}\n  {\"jack\":2,\"jack2\":3}\n''';\nload jsonStr.`rawData` as table1;\n\nsave overwrite table1 as json.`/tmp/jack`;\n```\n\n最后一句就是 `save` 句式了。 \n\n上面的 `save` 语句的含义是： 将 `table1` 进行覆盖保存，存储的格式为 Json 格式，保存位置是 `/tmp/jack`。 \n\n通常，`save` 语句里的数据源或者格式和 `load` 是保持一致的，配置参数也几乎保持一致。但是否能同时应用这两种句式由数据源的特性决定，典型的比如 `jsonStr` 就只支持 `load`,而不支持 `save`。\n\n`save` 语句也支持 `where/options` 条件子句。比如，如果用户希望保存时控制文件数量，那么可以使用 `where/options` 子句中的 `fileNum` 参数进行控制：\n\n```sql\nsave overwrite table1 as json.`/tmp/jack` where fileNum=\"10\";\n```\n\n### 2. Save 保存方式\n\n`save` 支持四种存储方式：\n\n1. overwrite：覆盖写\n\n```sql\n\tsave overwrite table1 as json.`/tmp/jack` where fileNum=\"10\";\n```\n\n表示覆盖 `/tmp/jack` 路径下的表 table1，并以 json 格式保存.\n\n2. append：追加写\n\n```sql\n\tsave append table1 as json.`/tmp/jack` where fileNum=\"10\";\n```\n\n表示追加内容至 `/tmp/jack` 路径下的表 table1，并以 json 格式保存.\n\n3. ignore：文件存在跳过不写\n\n```sql\n\tsave ignore table1 as json.`/tmp/jack` where fileNum=\"10\";\n```\n\n4. errorIfExists：文件存在则报错\n\n```sql\n\tsave errorIfExists table1 as json.`/tmp/jack` where fileNum=\"10\";\n```\n\n\n\n### 3. Save Connect 支持\n`save` 也支持 `connect` 语句的引用。\n\n比如：\n\n```sql\n\nselect 1 as a as tmp_article_table;\n\nconnect jdbc where\nurl=\"jdbc:mysql://127.0.0.1:3306/wow?characterEncoding=utf8&zeroDateTimeBehavior=convertToNull&tinyInt1isBit=false\"\nand driver=\"com.mysql.jdbc.Driver\"\nand user=\"xxxxx\"\nand password=\"xxxxx\"\nas db_1;\n\nsave append tmp_article_table as jdbc.`db_1.crawler_table`;\n```\n\n在这个例子中，我们通过`connect` 语句去连接了一个 jdbc 数据源，再通过 save 语句将处理好的库表存储进该数据源中。\n\n`connect` 语句并不是真的去连接数据库，而仅仅是方便后续记在同一数据源，避免在 `load/save` 句式中反复填写相同的参数。\n\n对于示例中的 `connect` 语句， jdbc + db_1 为唯一标记。 当系统遇到下面 `save` 语句中 jdbc.`db_1.crawler_table` 时，他会通过 jdbc 以及 db_1 找到所有的配置参数， 如 driver， user, url, 等等，然后自动附带上到 `save` 语句中。\n\n\n## 分支/If|Else\n\n传统 SQL 是不支持分支语句的，因此如果想要在 SQL 中添加判断或过滤条件，往往需要多条 SQL 拼接才能完成需求。但是在 Byzer-lang 中配合宏命令做到了分支语句的支持，允许我们正常使用 if/else，强化拓展了语言自身的能力。\n\n\n\n### 1. 基本用法\n\n一段最简单的分支语法示例：\n\n```sql\nset a = \"wow,jack\";\n!if ''' split(:a,\",\")[0] == \"jack\" ''';\n   select 1 as a as b;\n!else;\n   select 2 as a as b;\n!fi;\n\nselect * from b as output;\n```\n\n结果为：a：2。\n\n`!if/!else`  在 Byzer-lang 中并非关键字,都是 [宏函数](/byzer-lang/zh-cn/grammar/macro.md)。\n\n在上面的示例中：\n\n1. 先通过变量申明得到一个变量 `a`。 然后在宏函数 `!if` 只接受一个位置参数，因为是一个宏函数，调用的最后必须加上分号 `;` 。\n\n2. `!if` 后面接一个文本参数，该文本的内容是一个表达式。在表达式里可以使用 Spark SQL 支持所有函数。比如上面的例子是 `split` 函数。表达式也支持使用 register 句式注册的函数，本文后面部分会有使用示例。 \n\n3. 在条件表达式中使用 `:` 来标识一个变量。变量来源于 [set 句式](/byzer-lang/zh-cn/grammar/set.md)。比如示例中表达式的 `:a` 变量对应的值为 \"wow,jack\" 。如果表达式： \n\n```sql\nsplit(:a,\",\")[0] == \"jack\" \n```\n\n返回 true ， 那么会执行：\n\n```sql\nselect 1 as a as b;\n```\n\n这条 `select` 语句会通过 `as 语法` 生成一个临时表 `b`, 该表只有一个 `a` 字段，并且值为 `1`.\n\n如果返回 false， 那么会执行：\n\n```sql\nselect 2 as a as b;\n```\n\n这条 `select` 语句会通过 `as 语法` 生成一个临时表 `b`, 该表只有一个 `a` 字段，并且值为 `2`.\n\n示例代码最后通过下列语句对 `b` 表进行输出：\n\n```sql\nselect * from b as output;\n```\n\n从上面的例子可以看到，Byzer-lang 的条件判断语句具有以下特色：\n\n1. 语法设计遵循 SQL 的一些原则。比如采用 `and/or` 替代 `&&/||`。使用 `select` 语句做变量赋值\n2. 兼容 Spark SQL 函数\n3. 支持用户自定义函数（参看文章后半部分）\n\n\n\n### 2. 分支语句嵌套\n\nByzer-lang 也支持分支语句的嵌套。\n\n示例：\n\n```sql\nset a=\"jack,2\";\n\n!if ''' select split(:a,\",\")[0] as :name, split(:a,\",\")[1] as :num;\n:name == \"jack\" and :num == 3\n''';\n    select 0 as a as b;\n!elif ''' select split(:a,\",\")[1] as :num; :num==2 ''';\n    !if ''' 2==1 ''';\n       select 1.1 as a as b;\n    !else;\n       select 1.2 as a as b;\n    !fi;\n!else;\n  select 2 as a as b;\n!fi;\n\n\nselect * from b as output;\n```\n\n在上述代码中，`!if` 表达式里变得复杂了：\n\n```sql\n!if ''' select split(:a,\",\")[0] as :name, split(:a,\",\")[1] as :num;\n:name == \"jack\" and :num == 3\n''';\n```\n\n和第一个例子不同之处在于多了一个 `select` 句法结构， 该结构如下：\n\n\n```sql\nselect split(:a,\",\")[0] as :name, split(:a,\",\")[1] as :num;\n```\n\n在上面的示例代码中，通过 `select` 生成了 `:name` 和 `:num` 两个变量。\n\n接着，用户可以使用 `;` 对提交表达式的不同语句进行分割。 第二条语句是对新产生的两个变量进行条件表达式判定：\n\n```sql\n:name == \"jack\" and :num == 3\n```\n\nByzer-lang 会在执行时对变量 `:num` 自动进行类型转换，转换为数字。\n\n### 3. 表达式中变量的作用域\n\n在 `!if/!elif` 里申明的变量有效范围是整个 `!if/!fi` 区间。子 `!if/!else` 语句可以使用上层 `!if/!else` 语句的变量。 \n\n\n对于以下示例：\n\n```sql\nset name = \"jack\";\n!if '''select :name as :newname ;:name == \"jack\" ''';\n    !if ''' :newname == \"jack\" ''';\n       !println '''====1''';\n    !else;\n       !println '''====2 ''';\n    !fi;\n!else;\n   !println '''=====3''';\n!fi;\n```\n\n该语句输出为 `====1`，子 `!if` 语句中使用了上层 `!if` 语句中的 `select` 产生的 `:newname` 变量。\n\n同样的，用户也可以在分支语句内部的代码中引用条件表达式里的变量，比如：\n\n```sql\nset name = \"jack\";\n!if '''select concat(:name,\"dj\") as :newname ;:name == \"jack\" ''';\n    !if ''' :newname == \"jackdj\" ''';\n       !println '''====${newname}''';\n       select \"${newname}\" as a as b;\n    !else;\n       !println '''====2 ''';\n    !fi;\n!else;\n   !println '''=====3''';\n!fi;\n\nselect * from b as output;\n```\n\n在该示例中，用户在 `select`, `!println` 语句里通过 `${}` 引用了 `!if` 或者 `!elif` 里声明的变量。\n\n\n### 4. 结合 defaultParam 变量\n\n条件分支语句可以与强大的变量声明语法结合。\n\n这里主要介绍和 [defaultParam 变量](/byzer-lang/zh-cn/grammar/set.md) 的结合。\n\n比如：\n\n```sql\nset a = \"wow,jack\" where type=\"defaultParam\";\n!if ''' split(:a,\",\")[0] == \"jack\" ''';\n   select 1 as a as b;\n!else;\n   select 2 as a as b;\n!fi;\n\nselect * from b as output;\n\n```\n\n此时代码的输出会是 `2`。 但是如果在前面加一句：\n\n```sql\nset a = \"jack,\";\nset a = \"wow,jack\" where type=\"defaultParam\";\n!if ''' split(:a,\",\")[0] == \"jack\" ''';\n   select 1 as a as b;\n!else;\n   select 2 as a as b;\n!fi;\n\nselect * from b as output;\n```\n\n这个时候会输出 `1`。 这意味着，用户可以通过执行脚本时，动态在脚本最前面添加一些变量就可以覆盖掉脚本原有的变量，从而实现更加动态的控制脚本的执行流程。\n\n\n### 5. 在条件表达式中使用自定义函数\n\n前面提到, Byzer-lang 支持使用自定义 UDF 函数，经过注册的 UDF 函数，也可以用在条件分支语句中的条件表达式中。\n\n示例：\n\n```sql\nregister ScriptUDF.`` as title where \nlang=\"scala\"\nand code='''def apply()={\n   \"jack\"\n}'''\nand udfType=\"udf\";\n\n!if ''' title() == \"jack\" ''';\n   select 1 as a as b;\n!else;\n   select 2 as a as b;\n!fi;\n\nselect * from b as output;\n```\n\n### 6. !if/!else 子语句中表的生命周期问题以及解决办法\n\n在 Byzer-lang 中，表的生命周期是 session 级别的。这意味着在一个 session 中， 表都是会被自动注册在系统中的，除非被删除或者被重新定义了亦或是 session 失效。\nsession 级别的生命周期主要配套 notebook 使用，方便用户进行调试。 然而，这在使用 `!if/!else` 的时候则会有困惑发生。\n\n来看下面这个例子：\n\n```sql\n!if ''' 2==1 ''';\n   select 1 as a as b;\n!else;   \n!fi;\n\nselect * from b as output;\n```\n\n当第一次运行的时候，因为 `2==1` 会返回 false， 所以会执行 `!else` 后面的空分支。 接着我们再引用 `b` 进行查询，系统会报错，因为没有表 `b`。 \n\n于是我们修改下条件，将 `2==1` 修改为 `1==1` 时，此时，系统执行了 `select 1 as a as b;`, 产生了 `b` 表， 整个脚本正常运行。 \n\n再次，我们将 `1==1` 再次修改为 `2==1` 此时，系统输出了和条件 `1==1` 时一样的结果。这显然不符合逻辑。\n\n原因在于，系统记住了上次运行的 `b`,所以虽然当前没有执行 `select` 语句，但是依然有输出，从而造成错误。\n\n解决办法有两个：\n\n1. 请求参数设置 `sessionPerRequest`,这样每次请求表的生命周期都是 `request`。\n2. 在脚本里备注 `set __table_name_cache__ = \"false\";` 让系统不要记住表名，逻辑上是每次执行完脚本后，系统自动清理产生运行产生的临时表。\n\n其中第二个办法的使用示例如下：\n\n```sql\nset __table_name_cache__ = \"false\";\n!if ''' 2==1 ''';\n   select 1 as a as b;\n!else;   \n!fi;\n\nselect * from b as output;\n```\n\n## 注册函数，模型/Register\n\nRegister 句式在 Byzer-lang 中主要可以完成三类工作：\n\n1. 动态注册 Java/Scala 写的 UDF/UDAF 函数\n2. 将内置或者 Python 模型注册成 UDF 函数\n3. 在流式计算中，注册 watermark/window\n\n### 1. 注册 SQL 函数\n\n在 SQL 中，最强大的莫过于函数了。Byzer-lang 支持动态创建 UDF/UDAF 函数。\n\n示例代码：\n\n```sql\nregister ScriptUDF.`` as plusFun where\nlang=\"scala\"\nand udfType=\"udf\"\nand code='''\ndef apply(a:Double,b:Double)={\n   a + b\n}\n''';\n```\n\n上面代码的含义是，使用 ET ScriptUDF 注册一个函数叫 `plusFun`，这个函数使用 Scala 语言，函数的类型是 UDF,对应的实现代码在 code 参数里。\n\n在 Byzer-lang 中， 执行完上面代码后，用户可以直接在 `select` 语句中使用 `plusFun` 函数：\n\n```sql\n-- 创建数据表\n set data='''\n {\"a\":1}\n {\"a\":2}\n {\"a\":3}\n {\"a\":4}\n ''';\n load jsonStr.`data` as dataTable;\n\n -- 在 SQL 中使用 echofun\n select plusFun(a,2) as res from dataTable as output;\n```\n\n其中：\n\n1. lang 支持 java/scala\n2. udfType 支持 udf/udaf \n\n#### 1）通过变量持有代码片段\n\n代码片段也可以使用变量持有，然后在 ScriptUDF 中引用：\n\n```sql\nset plusFun='''\n    def apply(a:Double,b:Double)={\n       a + b\n    }\n''';\n\n-- 将脚本加载成表，在 byzer 中一切皆可成表 \n-- 这样处理起来就十分方便\nload script.`plusFun` as scriptTable;\n-- 将 `apply` 注册成名为 `plusFun` 的 UDF 函数 \nregister ScriptUDF.`scriptTable` as plusFun;\n-- 创建数据表\nset data='''\n  {\"a\":1}\n  {\"a\":2}\n  {\"a\":3}\n  {\"a\":4}\n''';\nload jsonStr.`data` as dataTable;\n-- 在 SQL 中使用 echofun\nselect plusFun(a,2) as res from dataTable as output;\n```\n\n一个变量可以持有多个方法，然后分别进行注册：\n\n```sql\nset plusFun='''\nclass A {\n\n    def apply(a:Double,b:Double)={\n       a + b\n    }\n\n    def hello(a:String)={\n       \"hello: \"+a\n    }\n}\n''';\n\n\nload script.`plusFun` as scriptTable;\nregister ScriptUDF.`scriptTable` as plusFun where methodName=\"apply\" and className=\"A\";\nregister ScriptUDF.`scriptTable` as helloFun options\nmethodName=\"hello\"  and className=\"A\";\n\n-- 在 SQL 中使用 echofun\nselect plusFun(1,2) as plus, helloFun(\"jack\") as jack as output;\n```\n\n#### 2）Scala UDAF 示例\n\n```sql\nset plusFun='''\nimport org.apache.spark.sql.expressions.{MutableAggregationBuffer, UserDefinedAggregateFunction}\nimport org.apache.spark.sql.types._\nimport org.apache.spark.sql.Row\nclass SumAggregation extends UserDefinedAggregateFunction with Serializable{\n    def inputSchema: StructType = new StructType().add(\"a\", LongType)\n    def bufferSchema: StructType =  new StructType().add(\"total\", LongType)\n    def dataType: DataType = LongType\n    def deterministic: Boolean = true\n    def initialize(buffer: MutableAggregationBuffer): Unit = {\n      buffer.update(0, 0l)\n    }\n    def update(buffer: MutableAggregationBuffer, input: Row): Unit = {\n      val sum   = buffer.getLong(0)\n      val newitem = input.getLong(0)\n      buffer.update(0, sum + newitem)\n    }\n    def merge(buffer1: MutableAggregationBuffer, buffer2: Row): Unit = {\n      buffer1.update(0, buffer1.getLong(0) + buffer2.getLong(0))\n    }\n    def evaluate(buffer: Row): Any = {\n      buffer.getLong(0)\n    }\n}\n''';\n\n\n--加载脚本\nload script.`plusFun` as scriptTable;\n--注册为UDF函数 名称为plusFun\nregister ScriptUDF.`scriptTable` as plusFun options\nclassName=\"SumAggregation\"\nand udfType=\"udaf\"\n;\n\nset data='''\n{\"a\":1}\n{\"a\":1}\n{\"a\":1}\n{\"a\":1}\n''';\nload jsonStr.`data` as dataTable;\n\n-- 使用plusFun\nselect a,plusFun(a) as res from dataTable group by a as output;\n```\n\n#### 3）Java 语言 UDF 示例\n\n\n```sql\nset echoFun='''\nimport java.util.HashMap;\nimport java.util.Map;\npublic class UDF {\n  public Map<String, Integer[]> apply(String s) {\n    Map<String, Integer[]> m = new HashMap<>();\n    Integer[] arr = {1};\n    m.put(s, arr);\n    return m;\n  }\n}\n''';\n\nload script.`echoFun` as scriptTable;\n\nregister ScriptUDF.`scriptTable` as funx\noptions lang=\"java\"\n;\n\n-- 创建数据表\nset data='''\n{\"a\":\"a\"}\n''';\nload jsonStr.`data` as dataTable;\n\nselect funx(a) as res from dataTable as output;\n```\n\n由于 Java 语言的特殊性，有如下几点注意事项：\n\n> 1. 传递的代码必须是一个 Java 类，并且默认系统会寻找 `UDF.apply()` 做为运行的 udf，如果需要特殊类名和方法名，需要在 `register` 时声明必要的 `options`，参考例子2。\n> 2. 不支持包名( package 声明)\n\n例子2：\n\n```sql\nset echoFun='''\nimport java.util.HashMap;\nimport java.util.Map;\npublic class Test {\n    public Map<String, String> test(String s) {\n      Map m = new HashMap<>();\n      m.put(s, s);\n      return m;\n  }\n}\n''';\n\nload script.`echoFun` as scriptTable;\n\nregister ScriptUDF.`scriptTable` as funx\noptions lang=\"java\"\nand className = \"Test\"\nand methodName = \"test\"\n;\n\n-- 创建数据表\nset data='''\n{\"a\":\"a\"}\n''';\nload jsonStr.`data` as dataTable;\n\nselect funx(a) as res from dataTable as output;\n```\n\n\n\n### 2. 注册模型\n\n具体使用方式如下：\n\n```sql\nregister  RandomForest.`/tmp/rf` as rf_predict;\n\nselect rf_predict(features) as predict_label from trainData\nas output;\n```\n\n`register` 语句的含义是： 将 `/tmp/rf ` 中的 RandomForest 模型注册成一个函数，函数名叫 rf_predict.\n\n`register` 后面也能接 `where/options` 子句：\n\n```sql\nregister  RandomForest.`/tmp/rf` as rf_predict\noptions algIndex=\"0\"\n-- and autoSelectByMetric=\"f1\" \n;\n```\n\n如果训练时同时训练了多个模型的话：\n\n1. `algIndex` 可以让用户手动指定选择哪个模型\n2. `autoSelectByMetric` 则可以通过一些指标，让系统自动选择一个模型。内置算法可选的指标有： f1|weightedPrecision|weightedRecall|accuracy。\n\n如果两个参数都没有指定话的，默认会使用 `f1` 指标。\n\n\n\n\n### 3. 流式程序中注册 Watermark\n\n在流式计算中，有 watermark 以及 window 的概念。我们可以使用 `Register` 句式来完成这个需求：\n\n```sql\n-- 为 table1 注册 watermark\nregister WaterMarkInPlace.`table1` as tmp1\noptions eventTimeCol=\"ts\"\nand delayThreshold=\"10 seconds\";\n```\n\n## 模块化/Include\n\n### Byzer Notebook 里的 Notebook 之间引用\n\nByzer-lang 提供了很好的 IDE 工具，诸如纯 Web 版本的 Byzer Notebook  ，还有 本地版本的 Byzer-desktop (基于VsCode), 他们都是以 Notebook 形式提供了对 Byzer 语言的支持，对于用户调试、管理和模块化 Byzer 代码具有非常大的价值。当然，还有程序员们喜欢的 Byzer-shell ,Byzer-cli ， 在 Byzer 的 All-in-one 版本里都默认包含了。\n\n话题拉回来，假设用户开发了一个 UDF 函数（Byzer 支持动态定义UDF函数，意味着不用编译，不用打包发布重启等繁琐流程），然后它可能会在很多 Notebook 里都用到这个函数。\n此时，用户可以将所有 UDF 函数都放到一个 Notebook 里，然后在其他 Notebook 里引用。 具体做法分成两步。\n\n第一步，创建一个 用于存储 UDF 的 Notebook, 比如 Notebook 名字叫 udfs.bznb,第一个cell的内容为：\n\n```sql\nregister ScriptUDF.`` as arrayLast\nwhere lang=\"scala\"\nand code='''\ndef apply(a:Seq[String])={\n    a.last\n}\n'''\nand udfType=\"udf\";\n```\n\n第二步，新创建一个 Notebook, 比如叫 job.bznb， 在该 Notebook 里可以通过如下方式引入 arrayLast 函数：\n\n```sql\ninclude http.`project.demo.udfs`;\nselect arrayLast(array(\"a\",\"b\")) as lastChar as output;\n```\n\n这个时候上面的代码就等价于：\n\n```sql\nregister ScriptUDF.`` as arrayLast\nwhere lang=\"scala\"\nand code='''\ndef apply(a:Seq[String])={\n    a.last\n}\n'''\nand udfType=\"udf\";\nselect arrayLast(array(\"a\",\"b\")) as lastChar as output;\n\n```\n\n实现了代码的模块化复用。\n\n在 Byzer Notebook 中，需要在一个 Notebook 里引入另外一个 Notebook，可以通过 Include语法，其中 http 和 project 是固定的。 后面  demo.udfs 则是目录路径，只不过用 . 替换了 /。\n\n假设 udfs 里有很多函数，不希望把所有的函数都包含进来，那么可以指定 Cell 的 序号 。 比如只包含第一个 cell, 那么可以这么写：\n\n```sql\ninclude http.`project.demo.udfs#1`;\nselect arrayLast(array(\"a\",\"b\")) as lastChar as output;\n```\n\n期待 Byzer notebook 以后可以支持给 cell 命名  \n\n### 代码片段的引用\n\n假设我们有个 case when (case when 其实是很有业务价值的东西)，我们可以创建一个 case_when 的一个 Notebook:\n\n```sql\nset gender_case_when = '''\n\nCASE \nWHEN gender=0 THEN \"男\"\nELSE \"女\"\nEND\n''';\n```\n\n然后我在某个 Notebook  比如 main 里就可以这么用：\n\n\n```sql\nselect 0 as gender as mockTable;\n\ninclude http.`project.demo.casewhen`;\n\nselect ${gender_case_when} as gender from mockTable\nas output;\n\n```\n\n上面的本质是把代码片段放到一个变量里去，然后在语句中引用变量。\n\n问题来了，在本例中，如果 case when 里的 gender 字段可能是变化的怎么办？ 可能有人叫 gender, 有人叫 sex， 该如何复用？ 这当然难不倒我们, 新写一段代码：\n\n```sql\nset gender_case_when = '''\n\nCASE \nWHEN {0}=0 THEN \"男\"\nELSE \"女\"\nEND\n''';\n\n```\n\n此时把原来写 gender 的地方改成 {0}, 然后调用时，这么调用：\n\n\n```sql\nselect 0 as gender as mockTable;\n\ninclude http.`project.demo.casewhen`;\n\nselect ${template.get(\"gender_case_when\",\"gender\")} as gender from mockTable\nas output;\n\n```\n\n\n我们使用 `template.get` 来获取模板以及使用位置参数来渲染这个模板。更多细节参考这篇专门的文章： Byzer Man：Byzer 模板编程入门\n\n### 宏函数的使用\n\nByzer 也支持函数的概念，这个函数和 SQL 中的函数不同， Byzer 的宏函数是对 SQL 代码进行复用。\n我们在 case_when Notebook 中再加一段代码：\n\n```sql\nset showAll='''\n\nselect CASE \nWHEN {0}=0 THEN \"男\"\nELSE \"女\"\nEND as gender from mockTable \nas output\n\n''';\n```\n\n\n在变量 showAll 中填写了一段完整的 Byzer 代码（注意，当前版本 Byzer 不支持 宏函数嵌套，也就是宏函数里不能再使用宏函数）。接着，我们可以在 main Notebook 中引用：\n\n\n```sql\nselect 0 as gender as mockTable;\n\ninclude http.`project.demo.casewhen#3`;\n\n!showAll gender;\n```\n\n\n通过 宏函数，也能有效提升我们对 Byzer 的封装性。\n\n### 在脚本中引入 Git 托管的 Byzer 代码\n\n几乎所有的语言都有模块化管理代码的能力，比如 Java 的 jar, Python的 Pip, Rust 的crate 等。 Byzer 也具有相同的能力。 Byzer 支持直接引用 git 仓库的中代码。假设用户开发了一个业务库，使用 Byzer 语句，此时他可以把代码放到 gitee 上，其他人就可以通过这个方式引用这个代码库：\n\n```sql\ninclude lib.`gitee.com/allwefantasy/lib-core`\nwhere \n-- commit=\"xxxxx\" and\nalias=\"libCore\";\n```\n\n接着可以可以引用里面的具体某个文件：\n\n```sql\ninclude local.`libCore.udf.hello`;\nselect hello() as name as output;\n```\n\n在上面的案例中，我们引用了 lib-core 项目里的一个 hello 函数，然后接着就可以在 select 语法中使用。include 也支持 commit 进行版本指定，很方便。\n结果如下：\n\n使用 Git 进行 Module 的托管，可以更好的对代码进行封装。\n\n另外，如果假设你已经进行过 lib 的include(下载到服务器上了)，那么你也可以按下面的方式\n应用已经缓存在本地的lib库：\n\n```sql\ninclude local.`gitee.com/allwefantasy/lib-core.udf.hello`;\nselect hello() as name as output;\n```\n\n### Byzer desktop\n\nByzer desktop 如果没有配置远程的引擎地址，默认会使用内置的引擎，这意味着我们可以使用Byzer 操作本地的文件。\n模块的使用和 Byzer Notebook 完全一致。但对于本地的脚本的引入略有区别，它使用 project 关键词，支持相对路径：\n\n```​sql\ninclude project.`./udf.hello`;\n```​\n\n我们可以看到， Byzer 提供了很强的代码复用能力，结构化管理能力，能够实现代码片段到模块级别的管理能力。\n对于提升用户效率，增强业务资产的沉淀能力带来很大的助力。\n\n## 断言支持\n\n断言可以让 Byzer 在 SQL 脚本中的任何一个位置实现中断，判断某个条件是否成立。\n\n```sql\nset abc='''\n{ \"x\": 120, \"y\": 100, \"z\": 260 ,\"dataType\":\"B group\"}\n{ \"x\": 160, \"y\": 100, \"z\": 260 ,\"dataType\":\"C group\"}\n{ \"x\": 170, \"y\": 100, \"z\": 260 ,\"dataType\":\"C group\"}\n{ \"x\": 150, \"y\": 100, \"z\": 260 ,\"dataType\":\"B group\"}\n{ \"x\": 110, \"y\": 100 ,\"dataType\":\"A group\"}\n{ \"x\": 130 ,\"dataType\":\"A group\"}\n{ \"x\": 140, \"y\": 200 ,\"dataType\":\"A group\"}\n''';\nload jsonStr.`abc` as table1;\n```\n> 注意：\n> \n> 1.下面相关算子，不带有Throw的不会打断脚本运行，并且会返回具体的异常数据集，通长用来做数据探查。\n> \n> 2.如果希望在执行的过程中，像执行代码一样遇到异常直接打断运行，可以使用带有Throw的算子，这样会抛出异常，不会返回数据集。\n\n### 常用单表或视图Data Quality验证算子\n#### assertNotNull tableName 'fieldName1,fieldName2...'\n\n判断表中的某些字段是否为空,默认会返回具体的非空数据集\n```sql\n!assertNotNull table1 'z';\n```\n#### assertNotNullThrow tableName 'fieldName1,fieldName2...' \n判断表中的某些字段是否为空,不满足条件则会抛出异常\n```sql\n!assertNotNullThrow table1 'z';\n```\n\n#### assertUniqueKey tableName 'fieldName1,fieldName2...'\n判断表中的某些字段是否唯一,默认会非唯一的字段名\n```sql\n!assertUniqueKey table1 \"z\";\n```\n\n\n#### assertUniqueKeyThrow tableName 'fieldName1,fieldName2...'\n判断表中的某些字段是否唯一,不满足条件则会抛出异常\n```sql\n!assertUniqueKeyThrow table1 \"z\";\n```\n\n#### assertUniqueKeys tableName 'fieldName1,fieldName2...'\n判断组合字段是否全局唯一,默认会返回具体的非唯一数据集\n```sql\n!assertUniqueKeys table1 \"dataType,y\";\n```\n\n\n\n#### assertUniqueKeysThrow tableName 'fieldName1,fieldName2...'\n判断组合字段是否全局唯一,不满足条件则会抛出异常\n```sql\n!assertUniqueKeysThrow table1 \"z,y\";\n```\n\n#### assertCondition tableName 'expression'\n判断表中的某些字段是否满足设定的条件,默认会返回具体的不满足条件的数据集\n```sql\n!assertCondition table1 \"x > 180\";\n```\n\n#### assertConditionThrow tableName 'expression'\n判断表中的某些字段是否满足设定的条件,不满足条件则会抛出异常 \n> 注意：当你使用spark3.3.0的时候这个功能会有bug，升级到更上面的版本不会有这个问题。\n> 详细原因请查看：https://issues.apache.org/jira/browse/SPARK-39612\n```sql\n!assertCondition table1 \"x > 180\";\n```\n\n\n#### 通用表达式校验\n\nByzer 支持断言，断言的语法如下：\n\n```sql\n!assert <tableName> <expr> <message>;\n```\n让我们来解释下上面的三个参数：\n\n- tableName: 表名，这个表名的表必须存在，否则会抛出异常。\n- expr: 一个表达式，这个表达式的值必须是一个 boolean 值，如果是 true，则不会抛出异常，如果是 false，则会抛出异常。\n- message: 异常信息，当 expr 为 false 时，这个信息会在抛出异常时显示。\n\n因为 Byzer 是使用 表 来进行上下语句的衔接的。所以，和传统语言直接对标量进行判定不同， Byzer 的断言是对表内的数据进行判定。\n\n##### 例子\n\n我们来看一个例子，假设我加载了一个数据集，我要判断该数据集不为空的情况下，才能继续执行后续的 SQL 语句,把结果保存起来。\n\n\n```sql\nload csv.`/tmp/upload/visual_data_0.csv` \nwhere inferSchema=\"true\" and header=\"true\"\nas vega_datasets;\n\nselect count(*) as v from vega_datasets as vega_datasets_count;\n!assert vega_datasets_count \n''' :v>0 ''' \n\"数据集不能为空\";\n\nsave overwrite vega_datasets as parquet.`/tmp/visual_data_0`;\n```\n\n上面的例子中，我们使用了 `!assert` 语句，来判断数据集的数量是否大于 0，如果不大于 0，则会抛出异常，异常信息是 \"数据集不能为空\"。\n但是判断自身，其实是通过 `select count(*) as v from vega_datasets as vega_datasets_count;` 这条辅助 SQL 语句来实现的，这条语句的结果会被传递给 `!assert` 语句，然后我们对 v 字段进行判断。\n\n判断中对于变量的引用使用了 `:<varName>` 的语法, 这种变量引用的方式，我们在 Byzer 的条件分支表达式里也会用到。\n\n## 注意\n\n1. 断言中的表必须是一个结果表（一般里面只会有一条记录），因为他会在内存中使用，如果表太大可能会导致系统崩溃。\n2. 断言会触发一次实际的SQL执行，可能会极大的降低了脚本的执行速度，请在确实需要的地方使用。\n\n## 举一反三\n\n如果我想看一个表是不是年份字段是不是重复，如果有的话，那么停止执行，否则往后执行，该怎么实现呢？\n下面的例子我们使用变量的方式\n\n```sql\nload csv.`/tmp/upload/visual_data_0.csv` \nwhere inferSchema=\"true\" and header=\"true\"\nas vega_datasets;\n\nset vega_datasets_count = `select count(*) as v from vega_datasets` where type=\"sql\" ;\nset vega_datasets_distinct_count = `select count(Year) as distinct_v from vega_datasets group by Year` where type=\"sql\" ;\n\nselect ${vega_datasets_count} as vega_datasets_count, ${vega_datasets_distinct_count} as vega_datasets_distinct_count as assertTable;\n\n!assert assertTable \n''' :vega_datasets_count == :vega_datasets_distinct_count ''' \n\"Year 字段不能有重复\";\n\nsave overwrite vega_datasets as parquet.`/tmp/visual_data_0`;\n```\n\n上面的例子中，我们使用了两个辅助 SQL 语句，来获取数据集的总数和去重后的总数，并且构建成一个新表，然后通过 `!assert` 语句来判断新表中这两个值是否相等，如果不相等，则会抛出异常，异常信息是 \"Year 字段不能有重复\"。\n\n为了做这个判断，我们相当于执行了两条count语句，这个在数据量大的时候，可能会导致脚本执行的很慢，所以请谨慎使用。\n\n#### Byzer 模块中使用 !assert 语法\n\n我们知道 Byzer 是支持模块的，也就是代码文件的的引用。模块在使用之前，需要用户传递一些参数，此时可以通过 !assert 来确定参数是否存在或者是否正确。\n\n下面的代码来自 一个示例模块\n\n```sql\n/**\nUsage:\n\nset inputTable=\"abc\";\ninclude local.`libCore.alg.xgboost`;\n**/\n\n!assert inputTable in __set__  ''' inputTable is missing. Try set inputTable=\"\" ''';\n!assert rayAddress in __set__ ''' rayAddress is missing. Try set rayAddress=\"127.0.0.1:10001\" ''';\n\nset inModule=\"true\" where type=\"defaultParam\";\nset rayAddress=\"127.0.0.1:10001\" where type=\"defaultParam\";\nset outputTable=\"xgboost_model\" where type=\"defaultParam\";\n\n!python conf \"rayAddress=${rayAddress}\";\n!python conf \"runIn=driver\";\n!python conf \"schema=file\";\n!python conf \"dataMode=model\";\n\n-- 引入python脚本\n!if ''' :inModule == \"true\" ''';\n!then;\n    !println \"include from module\";\n    !pyInclude local 'github.com/allwefantasy/lib-core.alg.xgboost.py' named rawXgboost;\n!else;\n    !println \"include from project\";\n    !pyInclude project 'src/algs/xgboost.py' named rawXgboost;\n!fi;  \n```\n\n在这个例子里，我们通过 !assert 检查用户是不是通过 set 设置了参数 inputTable, rayAddress的，如果没有，那么我们会报错。 这段脚本，用户可以这么用：\n\n```sql\n-- 引入第三方依赖\ninclude lib.`gitee.com/allwefantasy/lib-core`\nwhere alias=\"libCore\";\n\n-- 调用依赖里的模块\nset inputTable=\"abc\";\ninclude local.`libCore.alg.xgboost`;\n```\n\n## 扩展/Train|Run|Predict\n\nTrain/Run/Predict 都属于 Byzer-lang 里独有的并且可扩展的句式，一般用于机器学习模型的训练和预测，以及特征工程相关的数据处理操作。\n\n想了解更多 [内置算法](/byzer-lang/zh-cn/ml/algs/README.md) 和 [特征工程](/byzer-lang/zh-cn/ml/feature/README.md) 算子的应用，可跳转置对应章节。\n\n### 1. 基础语法\n\n#### Train\n\n`train` 顾名思义，就是进行训练，主要是对算法进行训练时使用。下面是一个比较典型的示例：\n\n```sql\n\nload json.`/tmp/train` as trainData;\n\ntrain trainData as RandomForest.`/tmp/rf` where\nkeepVersion=\"true\"\nand fitParam.0.featuresCol=\"content\"\nand fitParam.0.labelCol=\"label\"\nand fitParam.0.maxDepth=\"4\"\nand fitParam.0.checkpointInterval=\"100\"\nand fitParam.0.numTrees=\"4\"\n;\n```\n\n- 第一行代码，含义是加载位于 `/tmp/train` 目录下的，数据格式为 JSON 的数据，并且给该表取名为 `trainData`；\n- 第二行代码，则表示提供 `trainData` 为数据集，使用算法 RandomForest，将模型保存在 `/tmp/rf` 下，训练的参数为 `fitParam.0.*` 参数组里指定的那些。其中 `fitParam.0` 表示第一组参数，用户可以递增设置 N 组，Byzer-lang 会自动运行多组，最后返回结果列表。例如：\n\n```sql\nload json.`/tmp/train` as trainData;\n\ntrain trainData as RandomForest.`/tmp/rf` where\n-- 每次模型不要覆盖，保持版本\nkeepVersion = \"true\"\nand `fitParam.0.labelCol`= \"label\"  --y标签\nand `fitParam.0.featuresCol`= \"features\"  -- x特征\nand `fitParam.0.maxDepth`= \"4\"\n\n--设置了两组参数同时运行可对比结果优劣\nand `fitParam.1.labelCol`= \"label\"  --y标签\nand `fitParam.1.featuresCol`= \"features\"  -- x特征\nand `fitParam.1.maxDepth`= \"10\";\n```\n\n#### Run\n\n`run` 的语义是对数据进行处理，而不是训练。\n\n下面来看一个例子：\n\n```sql\nrun testData as TableRepartition.`` where partitionNum=\"5\" as newdata; \n```\n\n格式和 `train` 是一致的，其含义为运行 `testData` 数据集，使用内置插件 TableRepartition 对其重分区处理，\n处理的参数是 `partitionNum=\"5\"`，最后处理后的表叫 `newdata`。\n\n\n#### Predict\n\n`predict` 顾名思义，应该和机器学习相关预测相关。比如上面的 train 示例中，用户将随机森林的模型放在了\n`/tmp/rf` 目录下，用户可以通过 `predict` 语句加载该模型，并且对表 `testData` 进行预测。\n\n示例代码如下：\n\n```sql\npredict testData as RandomForest.`/tmp/rf`;\n```\n\n## 宏函数/Macro Function\n\nByzer-lang 中的宏函数和 `select` 句式中函数是不一样的。 宏函数主要是为了复用 Byzer-lang 代码。\n\n### 1. 基础用法\n\n以加载 `excel` 文件的代码为例:\n\n```sql\nload excel.`./example-data/excel/hello_world.xlsx` \nwhere header=\"true\" \nas hello_world;\n\nselect hello from hello_world as output;\n```\n\n如果每次都写完整的 `load` 语句，可能会比较繁琐。此时用户可以将其封装成一个宏函数：\n\n```sql\nset loadExcel = '''\nload excel.`{0}` \nwhere header=\"true\" \nas {1}\n''';\n\n!loadExcel ./example-data/excel/hello_world.xlsx helloTable;\n\n```\n\n在上面示例代码中，分成两步，第一步是定义一个变量，该变量的值为一段 Byzer-lang 代码。代码中的 `{0}` , `{1}` 等为位置参数，会在调用的时候被替换。\n第二步，使用 `!` 实现宏函数的调用，参数传递则使用类似命令行的方式。\n\n如果参数中包含空格等特殊字符，可以将参数括起来：\n\n```sql\nset loadExcel = '''\nload excel.`{0}` \nwhere header=\"true\" \nas {1}\n''';\n\n!loadExcel \"./example-data/excel/hello_world.xlsx\" \"helloTable\";\n```\n\n宏函数也支持命名参数：\n\n```sql\nset loadExcel = '''\nload excel.`${path}` \nwhere header=\"true\" \nas ${tableName}\n''';\n\n!loadExcel _ -path ./example-data/excel/hello_world.xlsx -tableName helloTable;\n```\n\n`-path` 后面的参数对应  `loadExcel` 函数体里的 `${path}`, 同理 `tableName`。\n\n注意，为了识别命名参数，宏函数要求第一个参数是 `_` 。\n\n### 2. 作用域\n\n宏函数声明后即可使用。 可以重复声明，后声明的会覆盖前面声明的。\n\n### 3. 宏函数的限制\n\n宏函数的使用，目前也有几个限制：\n\n1. 宏函数体里，最后一条语句不需要分号\n2. 宏函数里不能嵌套宏函数\n\n第一条限制比较容易理解。\n\n第二条限制可以通过下面的代码来展示：\n\n```sql\nset hello = '''\n!hdfs -ls /;\nselect 1 as a as output\n''';\n\n!hello;\n```\n\n该语句包含了一个内置的宏函数 `!hdfs`, 所以是非法的。\n\n## 注册大模型为UDF函数\n\nByzer SQL 可以连接一个已经部署好的模型实例，然后将其转换成 SQL 函数，具体做法如下；\n\n```\n!byzerllm setup single;\n\nrun command as LLM.`` where \naction=\"infer\"\nand reconnect=\"true\"\nand pretrainedModelType=\"saas/openai\"\nand udfName=\"deepseek_chat\";\n```\n\n上面是一个固定语法方式，唯一需要修改的事 pretrainedModelType 和 udfName，pretrainedModelType 是模型类型， saas/ 表示是saas模型，反斜杠后面\n则表示模型提供商，不过很多模型提供商都可以使用 openai 接口调用。udfName 是注册的函数名，需要保持和已经部署好的模型实例同名。\n\n\n## 大模型相关的辅助 SQL 函数用于自然语言处理\n\n### llm_param 函数\n\n#### 描述\n`llm_param` 函数用于设置 LLM 的参数。\n\n#### 语法\n```sql\nllm_param(map(...))\n```\n\n#### 参数\n- `map(...)`: 一个包含键值对的映射，用于设置 LLM 的各种参数。\n\n#### 示例\n```sql\nllm_param(map(\n    \"instruction\", llm_prompt('...')\n))\n```\n\n#### 说明\n- 在示例中，我们设置了一个名为 \"instruction\" 的参数，其值由 `llm_prompt` 函数生成。\n- 可以根据需要在 map 中添加更多参数，如模型名称、温度等。\n\n### llm_prompt 函数\n\n#### 描述\n`llm_prompt` 函数用于构建发送给 LLM 的提示文本。\n\n#### 语法\n```sql\nllm_prompt('prompt_text', array(...))\n```\n\n#### 参数\n- `'prompt_text'`: 提示文本模板，可以包含占位符 `{0}`, `{1}` 等。\n- `array(...)`: 一个数组，包含用于填充提示文本模板中占位符的值。\n\n#### 示例\n```sql\nllm_prompt('\n根据下面提供的信息，回答用户的问题。\n信息上下文：\n```\n{0}\n```\n用户的问题： Byzer-SQL 是什么?\n', array(context))\n```\n\n#### 说明\n- 提示文本中的 `{0}` 将被 `array(context)` 中的值替换。\n- 可以使用多个占位符 (`{0}`, `{1}`, ...) 并在数组中提供相应的值。\n\n### llm_result 函数\n\n#### 描述\n`llm_result` 函数用于从 LLM 的响应中提取结果。\n\n#### 语法\n```sql\nllm_result(response)\n```\n\n#### 参数\n- `response`: LLM 的原始响应。\n\n#### 示例\n```sql\nselect llm_result(response) as result from q3 as output;\n```\n\n#### 说明\n- 此函数通常用于从 LLM 的响应中提取有用的信息，并将其格式化为所需的输出格式。\n\n### llm_stack 函数\n\n`llm_stack` 函数是用于在多轮对话中维持上下文的一个重要工具。它的主要作用是将前一轮对话的响应与新的指令结合，以便在后续的对话中保持连贯性和上下文awareness。\n\n下面是一段示例代码：\n\n```sql\nselect \ndeepseek_chat(llm_param(map(\n              \"instruction\",'我是威廉，请记住我是谁。'\n)))\nas response as table1;\nselect llm_result(response) as result from table1 as output;\n\nselect \ndeepseek_chat(llm_stack(response,llm_param(map(\n              \"instruction\",'请问我是谁？'\n))))\nas response from table1\nas table2;\nselect llm_result(response) as result from table2 as output;\n```\n\n让我们详细分析一下这个函数的使用：\n\n1. 函数语法：\n   ```sql\n   llm_stack(previous_response, new_instruction)\n   ```\n\n2. 参数说明：\n   - `previous_response`：前一轮对话的响应。在您的例子中，这是来自 `table1` 的 `response`。\n   - `new_instruction`：新的指令，通常通过 `llm_param` 函数设置。\n\n3. 使用场景：\n   在您的例子中，`llm_stack` 被用于两轮对话中：\n   - 第一轮：介绍 \"我是威廉\"\n   - 第二轮：询问 \"请问我是谁？\"\n\n4. 工作原理：\n   - `llm_stack` 函数会将第一轮对话的响应（即模型记住了\"威廉\"这个身份）与第二轮的新指令（询问身份）结合起来。\n   - 这样做可以让模型在回答第二个问题时，依然记得第一轮对话中提到的信息。\n\n5. 在您的代码中的应用：\n   - 第一个查询设置了初始上下文（介绍威廉）。\n   - 第二个查询使用 `llm_stack` 来确保模型在回答 \"我是谁\" 的问题时，能够记住之前介绍的身份信息。\n\n通过使用 `llm_stack`，您可以创建更自然、更连贯的多轮对话，使得大语言模型能够在整个对话过程中保持上下文awareness，提供更准确和相关的回答。这在创建聊天机器人、问答系统或任何需要维持对话历史的应用中特别有用。\n\n### 模型 UDF 函数\n\n任何模型注册为 UDF 函数后，都有相同的调用方式。比如上面的 `deepseek_chat`, 语法如下:\n\n```sql\ndeepseek_chat(llm_param(...))\n```\n通过将模型 UDF 函数和其他辅助函数结合，让我们可以对SQL中的文本字段做自然语言处理，比如判断正负面情感、生成文本、回答问题等等。\n\n### 使用 Byzer-SQL 模型 UDF 函数完成图片处理\n\ngpt4o_mini_chat 是我们注册的一个多模态模型 UDF 函数，可以用来处理图片。\n\n\n```sql\nload binaryFile.`/tmp/upload/a082bf7e-c9b7-469c-a386-321fdeb74eeb_00001_.png` as images;\n\nselect \nllm_result(gpt4o_mini_chat(llm_param(\nmap(\n   \"instruction\",to_json(array(map(\n    \"image\",base64(content),\n    \"text\",\"详细描述图片里都有啥\"\n   )))\n              \n))))\nas response from images as table1;\n```\n\n根据上面的示例代码，可以使用 binaryFile 来加载图片(或者图片目录)，然后就可以使用 gpt4o_mini_chat 来处理了。\n注意\n1. 模型UDF函数一定要通过 llm_result 函数将其转化为文本字段\n2. 如果是要做判断的，可以让模型只输出 YES 或者 NO 两种情况，然后通过 like 来匹配。\n\n### 使用 Byzer-SQL 模型 UDF 函数完成表格文本字段的自然语言处理以及统计任务\n\n下面我们展示如何组合这些大模型辅助函数，完成一个简单的任务：统计用户正面评论的数量。\n\n```sql\nselect \"这个点心太好吃了\" as \ncontext as rag_table;\n\nselect \nllm_result(deepseek_chat(llm_param(map(\n              \"instruction\",llm_prompt('\n\n根据下面提供的信息，回答用户的问题。\n\n信息上下文：\n```\n{0}\n```\n\n用户的问题： 用户的评论是正面还是负面的。\n请只输出 “正面” 或者 “负面”\n',array(context))\n\n))))\n\nas response from rag_table as q3;\n\nselect count(*) as positive_counter from q3 where response like '%正面%' as output;\n\n\n```\n\n在这个示例中：\n1. 我们首先创建了一个包含上下文信息的表 `rag_table`。\n2. 然后使用 `llm_param` 和 `llm_prompt` 构建 prompt 指令。\n3. 将构建的指令传递给 `deepseek_chat` 函数（这可能是一个特定的 LLM 接口）。\n4. 最后，使用 `llm_result` 函数处理 LLM 的响应,得到的是一段文本，因为我们已经要求 deepseek_chat 输出包含`正面` 或者`负面`的文本了，但考虑到大模型会有一些额外的字符输出，不会只是输出我们要求的文字，所以通过 `like` 来进行匹配，从而过滤出正面评论，然后完成最后的统计结果。\n\n通过这种方式，Byzer-SQL 能够无缝地集成 LLM 功能，使得在 SQL 环境中进行复杂的自然语言处理任务变得简单而直观。\n\n\n### 注意事项\n\n1. 务必要理解模型 UDF 函数的使用场景，仅局限对某个字段的自然语言处理上，不要滥用，大部分问题应该都通过标准的 Byzer-SQL 统计聚合来完成。\n2. llm_result 等以 llm_ 开头函数，只能配合模型 UDF 函数使用，不能单独使用。\n3. 在使用了模型UDF函数的 select 语句中，请使用hint  /*+ REPARTITION(500) */ 来提高性能，类似 SELECT /*+ REPARTITION(500) */ ，其中里面的数值 500 可以根据需求进一步使用更大的数值。", "tag": ""}], "modify_time": 1726672883.8881247}
{"file_path": "/Users/allwefantasy/projects/llm_friendly_packages/github.com/allwefantasy/reactjs/README.md", "relative_path": "reactjs/README.md", "content": [{"module_name": "##File: /Users/allwefantasy/projects/llm_friendly_packages/github.com/allwefantasy/reactjs/README.md", "source_code": "# ReactJS + TailwindCSS 快速指南\n\n## 准备项目/环境\n\n```bash\nmkdir <PROJECT_NAME>\ncd  <PROJECT_NAME>\n\nnpx create-react-app frontend --template typescript\ncd frontend\nrm -rf .git\nnpm install -D tailwindcss postcss autoprefixer\nnpx tailwindcss init -p\nnpm install axios react-router-dom\nnpm install --save-dev @types/react-router-dom\n\ncd ..\nauto-coder init --source_dir .\n```\n\ntailwindcss 需要配置一下，修改 `frontend/src/index.css`,在最前面添加:\n\n```css\n@import 'tailwindcss/base';\n@import 'tailwindcss/components';\n@import 'tailwindcss/utilities';\n```\n\n然后修改`tailwind.config.js`:\n\n```javascript\n/** @type {import('tailwindcss').Config} */\nmodule.exports = {  \n  content: ['./src/**/*.{js,jsx,ts,tsx}', './public/index.html'],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n}\n```\n\n## 注意事项\n\n1. 当你进行编程的请使用 react-router-dom v6 版本的API。\n2. 整体技术组合是：reactjs + typescript + tailwindcss\n\n下面的 Makefile 内容可以通过运行 make ts 用于在一个项目目录里创建一个 frontend 应用，然后使用前面提到的 reactjs + typescript + tailwindcss 技术栈。\n\n```makefile\n# Makefile for running the translation service\n\n# The Python interpreter to use\nPYTHON := python\n\nFRONTEND_DIR = ./frontend\n\n\n# Help command to display available commands\nhelp:\n\t@echo \"Available commands:\"\n\t@echo \"  make run  - Run the translation service\"\n\t@echo \"  make help - Display this help message\"\n\nts: create_project install_dependencies init_tailwind configure\n\ncreate_project:\t\n\tnpx create-react-app frontend --template typescript\n\tcd $(FRONTEND_DIR) && rm -rf .git\n\ninstall_dependencies:\n\tcd $(FRONTEND_DIR) && npm install -D tailwindcss postcss autoprefixer\n\tcd $(FRONTEND_DIR) && npm install axios react-router-dom\n\tcd $(FRONTEND_DIR) && npm install --save-dev @types/react-router-dom\n\ninit_tailwind:\n\tcd $(FRONTEND_DIR) && npx tailwindcss init -p\n\nconfigure:\n\t@echo \"@import 'tailwindcss/base';\" | cat - $(FRONTEND_DIR)/src/index.css > temp && mv temp $(FRONTEND_DIR)/src/index.css\n\t@echo \"@import 'tailwindcss/components';\" >> $(FRONTEND_DIR)/src/index.css\n\t@echo \"@import 'tailwindcss/utilities';\" >> $(FRONTEND_DIR)/src/index.css\n\t@echo \"/** @type {import('tailwindcss').Config} */\" > $(FRONTEND_DIR)/tailwind.config.js\n\t@echo \"module.exports = {\" >> $(FRONTEND_DIR)/tailwind.config.js\n\t@echo \"  content: ['./src/**/*.{js,jsx,ts,tsx}', './public/index.html'],\" >> $(FRONTEND_DIR)/tailwind.config.js\n\t@echo \"  theme: {\" >> $(FRONTEND_DIR)/tailwind.config.js\n\t@echo \"    extend: {},\" >> $(FRONTEND_DIR)/tailwind.config.js\n\t@echo \"  },\" >> $(FRONTEND_DIR)/tailwind.config.js\n\t@echo \"  plugins: [],\" >> $(FRONTEND_DIR)/tailwind.config.js\n\t@echo \"}\" >> $(FRONTEND_DIR)/tailwind.config.js\n\nclean:\n\trm -rf frontend\n```  \n\n", "tag": ""}], "modify_time": 1725000381.3347642}
{"file_path": "/Users/allwefantasy/projects/llm_friendly_packages/github.com/allwefantasy/byzer-llm/.DS_Store", "relative_path": "byzer-llm/.DS_Store", "content": [], "modify_time": 1723814486.092453}
{"file_path": "/Users/allwefantasy/projects/llm_friendly_packages/github.com/allwefantasy/byzer-llm/README.md", "relative_path": "byzer-llm/README.md", "content": [{"module_name": "##File: /Users/allwefantasy/projects/llm_friendly_packages/github.com/allwefantasy/byzer-llm/README.md", "source_code": "# byzerllm 大模型编程快速指南\n\n本文示例 [Notebook](../../notebooks/003_byzerllm_大模型编程快速指南.ipynb)\n\n## 安装\n\n```bash\npip install -U byzerllm\nray start --head\n```\n## 启动一个模型代理\n\nbyzerllm 支持私有化模型或者SaaS模型的部署。\n\n这里以 deepseek 官方API 为例：\n\n```bash\neasy-byzerllm deploy deepseek-chat --token xxxxx --alias deepseek_chat\n```\n\n或者跬基流动API:\n\n```bash\neasy-byzerllm deploy alibaba/Qwen1.5-110B-Chat --token xxxxx --alias qwen110b_chat\n```\n\n将上面的 API KEY 替换成你们自己的。\n\n如果你想部署私有化模型或者对接 Ollama 等更多需求，参考 [002_使用byzerllm进行模型部署.md](./002_使用byzerllm进行模型部署.md) 或者 [README.md](../../README.md)。\n\n之后，你就可以在代码里使用  deepseek_chat 或者 qwen110b_chat  访问模型了。\n\n## hello world\n\n来和我们的大模型打个招呼:\n\n```python\nimport byzerllm\n\nllm = byzerllm.ByzerLLM.from_default_model(model=\"deepseek_chat\")\n\n@byzerllm.prompt(llm=llm)\ndef hello(q:str) ->str:\n    '''\n    你好, {{ q }}\n    '''\n\ns = hello(\"你是谁\")    \nprint(s)\n\n## 输出:\n## '你好！我是一个人工智能助手，专门设计来回答问题、提供信息和帮助解决问题。如果你有任何疑问或需要帮助，请随时告诉我。'\n```\n\n恭喜，你和大模型成功打了招呼！\n\n可以看到，我们通过 `@byzerllm.prompt` 装饰器，将一个方法转换成了一个大模型的调用，然后这个方法的主题是一段文本，文本中\n使用了 jinja2 模板语法，来获得方法的参数。当正常调用该方法时，实际上就发起了和大模型的交互，并且返回了大模型的结果。\n\n在 byzerllm 中，我们把这种方法称之为 prompt 函数。\n\n## 查看发送给大模型的prompt\n\n很多情况你可能需要调试，查看自己的 prompt 渲染后到底是什么样子的，这个时候你可以通过如下方式\n获取渲染后的prompt:\n\n```python\nhello.prompt(\"你是谁\")\n## '你好, 你是谁'\n```            \n\n## 动态换一个模型\n\n前面的 hello 方法在初始化的时候，我们使用了默认的模型 deepseek_chat，如果我们想换一个模型，可以这样做：\n\n```python\nhello.with_llm(llm).run(\"你是谁\")\n## '你好！我是一个人工智能助手，专门设计来回答问题、提供信息和帮助解决问题。如果你有任何疑问或需要帮助，请随时告诉我。'\n```\n\n通过 with_llm 你可以设置一个新的 llm 对象，然后调用 run 方法，就可以使用新的模型了。\n\n## 超长文本生成\n\n我们知道，大模型一次生成的长度其实是有限的，如果你想生成超长文本，你可能需手动的不断获得\n生成结果，然后把他转化为输入，然后再次生成，这样的方式是比较麻烦的。\n\nbyzerllm 提供了更加易用的 API :\n\n```python\nimport byzerllm\nfrom byzerllm import ByzerLLM\n\nllm = ByzerLLM.from_default_model(\"deepseek_chat\")\n\n@byzerllm.prompt()\ndef tell_story() -> str:\n    \"\"\"\n    讲一个100字的故事。    \n    \"\"\"\n\n\ns = (\n    tell_story.with_llm(llm)\n    .with_response_markers()\n    .options({\"llm_config\": {\"max_length\": 10}})\n    .run()\n)\nprint(s)\n\n## 从前，森林里住着一只聪明的小狐狸。一天，它发现了一块闪闪发光的宝石。小狐狸决定用这块宝石帮助森林里的动物们。它用宝石的光芒指引迷路的小鹿找到了回家的路，用宝石的温暖治愈了受伤的小鸟。从此，小狐狸成了森林里的英雄，动物们都感激它的善良和智慧。\n```\n\n实际核心部分就是这一行：\n\n```python\ntell_story.with_llm(llm)\n    .with_response_markers()    \n    .run()\n```\n\n我们只需要调用 `with_response_markers` 方法，系统就会自动的帮我们生成超长文本。\n在上面的案例中，我们通过\n\n```python\n.options({\"llm_config\": {\"max_length\": 10}})\n```\n\n认为的限制大模型一次交互最多只能输出10个字符，但是系统依然自动完成了远超过10个字符的文本生成。\n\n## 对象输出\n\n前面我们的例子都是返回字符串，但是我们也可以返回对象，这样我们就可以更加灵活的处理返回结果。\n\n```python\nimport pydantic \n\nclass Story(pydantic.BaseModel):\n    '''\n    故事\n    '''\n\n    title: str = pydantic.Field(description=\"故事的标题\")\n    body: str = pydantic.Field(description=\"故事主体\")\n\n@byzerllm.prompt()\ndef tell_story()->Story:\n    '''\n    讲一个100字的故事。    \n    '''\n\ns = tell_story.with_llm(llm).run()\nprint(isinstance(s, Story))\nprint(s.title)\n\n## True\n## 勇敢的小鸟\n```\n\n可以看到，我们很轻松的将输出转化为格式化输出。\n\n## 自定义字段抽取\n\n前面的结构化输出，其实会消耗更多token,还有一种更加精准的结构化输出方式。\n比如让大模型生成一个正则表达式，但实际上大模型很难准确只输出一个正则表达式，这个时候我们可以通过自定义抽取函数来获取我们想要的结果。\n\n\n```python\nfrom loguru import logger\nimport re\n\n@byzerllm.prompt()\ndef generate_regex_pattern(desc: str) -> str:\n    \"\"\"\n    根据下面的描述生成一个正则表达式，要符合python re.compile 库的要求。\n\n    {{ desc }}\n\n    最后生成的正则表达式要在<REGEX></REGEX>标签对里。\n    \"\"\"    \n\ndef extract_regex_pattern(regex_block: str) -> str:    \n    pattern = re.search(r\"<REGEX>(.*)</REGEX>\", regex_block, re.DOTALL)\n    if pattern is None:\n        logger.warning(\"No regex pattern found in the generated block:\\n {regex_block}\")\n        raise None\n    return pattern.group(1)\n\npattern = \"匹配一个邮箱地址\"\nv = generate_regex_pattern.with_llm(llm).with_extractor(extract_regex_pattern).run(desc=pattern)\nprint(v)\n## ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\n```\n\n在上面的例子里，我们根据一句话生成一个正则表达式。我们通过 `with_extractor` 方法，传入了一个自定义的抽取函数，这个函数会在大模型生成结果后，对结果进行处理，然后返回我们想要的结果。\n\n我们在 prompt 明确说了，生成的结果要放到 `<REGEX></REGEX>` 标签对里，然后我们通过 extract_regex_pattern 函数，从结果中提取出了我们想要的正则表达式。\n\n## 在实例方法中使用大模型\n\n```python\nimport byzerllm\ndata = {\n    'name': 'Jane Doe',\n    'task_count': 3,\n    'tasks': [\n        {'name': 'Submit report', 'due_date': '2024-03-10'},\n        {'name': 'Finish project', 'due_date': '2024-03-15'},\n        {'name': 'Reply to emails', 'due_date': '2024-03-08'}\n    ]\n}\n\n\nclass RAG():\n    def __init__(self):        \n        self.llm = byzerllm.ByzerLLM()\n        self.llm.setup_template(model=\"deepseek_chat\",template=\"auto\")\n        self.llm.setup_default_model_name(\"deepseek_chat\")        \n    \n    @byzerllm.prompt(lambda self:self.llm)\n    def generate_answer(self,name,task_count,tasks)->str:\n        '''\n        Hello {{ name }},\n\n        This is a reminder that you have {{ task_count }} pending tasks:\n        {% for task in tasks %}\n        - Task: {{ task.name }} | Due: {{ task.due_date }}\n        {% endfor %}\n\n        Best regards,\n        Your Reminder System\n        '''        \n\nt = RAG()\n\nresponse = t.generate_answer(**data)\nprint(response)\n\n## 输出:\n## Hello Jane Doe,\n##I hope this message finds you well. I wanted to remind you of your 3 pending tasks to ensure you stay on track:\n## 1. **Submit report** - This task is due on **2024-03-10**. Please ensure that you allocat\n```\n\n这里我们给了个比较复杂的例子，但我们可以看到，给一个实例prompt方法和普通prompt 方法差异不大。\n唯一的区别是如果你希望在定义的时候就指定大模型，使用一个lambda函数返回实例的 llm 对象即可。\n\n```python\n@byzerllm.prompt(lambda self:self.llm)\n```\n\n你也可以不返回，在调用的时候通过 `with_llm` 方法指定 llm 对象。\n\n此外，这个例子也展示了如何通过jinja2模板语法，来处理复杂的结构化数据。\n\n## 通过 Python 代码处理复杂入参\n\n上面的一个例子中，我们通过 jinja2 模板语法，来处理复杂的结构化数据，但是有时候我们可能需要更加复杂的处理，这个时候我们可以通过 Python 代码来处理。\n\n```python\nimport byzerllm\n\ndata = {\n    'name': 'Jane Doe',\n    'task_count': 3,\n    'tasks': [\n        {'name': 'Submit report', 'due_date': '2024-03-10'},\n        {'name': 'Finish project', 'due_date': '2024-03-15'},\n        {'name': 'Reply to emails', 'due_date': '2024-03-08'}\n    ]\n}\n\n\nclass RAG():\n    def __init__(self):        \n        self.llm = byzerllm.ByzerLLM.from_default_model(model=\"deepseek_chat\")\n    \n    @byzerllm.prompt()\n    def generate_answer(self,name,task_count,tasks)->str:\n        '''\n        Hello {{ name }},\n\n        This is a reminder that you have {{ task_count }} pending tasks:\n            \n        {{ tasks }}\n\n        Best regards,\n        Your Reminder System\n        '''\n        \n        tasks_str = \"\\n\".join([f\"- Task: {task['name']} | Due: { task['due_date'] }\" for task in tasks])\n        return {\"tasks\": tasks_str}\n\nt = RAG()\n\nresponse = t.generate_answer.with_llm(t.llm).run(**data)\nprint(response)\n\n## Just a gentle nudge to keep you on track with your pending tasks. Here's a quick recap:....\n```\n\n在这个例子里，我们直接把 tasks 在方法体里进行处理，然后作为一个字符串返回，最够构建一个字典，字典的key为 tasks,然后\n你就可以在 docstring 里使用 `{{ tasks }}` 来引用这个字符串。\n\n这样对于很复杂的入参，就不用谢繁琐的 jinja2 模板语法了。\n\n## 如何自动实现一个方法\n\n比如我定义一个签名，但是我不想自己实现里面的逻辑，让大模型来实现。这个在 byzerllm 中叫 function impl。我们来看看怎么\n实现:\n\n```python\nimport pydantic\nclass Time(pydantic.BaseModel):\n    time: str = pydantic.Field(...,description=\"时间，时间格式为 yyyy-MM-dd\")\n\n\n@llm.impl()\ndef calculate_current_time()->Time:\n    '''\n    计算当前时间\n    '''\n    pass \n\n\ncalculate_current_time()\n#output: Time(time='2024-06-14')\n```\n\n在这个例子里，我们定义了一个 calculate_current_time 方法，但是我们没有实现里面的逻辑，我们通过 `@llm.impl()` 装饰器，让大模型来实现这个方法。\n为了避免每次都要“生成”这个方法，导致无法适用，我们提供了缓存，用户可以按如下方式打印速度：\n\n```python\nstart = time.monotonic()\ncalculate_current_time()\nprint(f\"first time cost: {time.monotonic()-start}\")\n\nstart = time.monotonic()\ncalculate_current_time()\nprint(f\"second time cost: {time.monotonic()-start}\")\n\n# output:\n# first time cost: 6.067266260739416\n# second time cost: 4.347506910562515e-05\n```\n可以看到，第一次执行花费了6s,第二次几乎是瞬间完成的，这是因为第一次执行的时候，我们实际上是在生成这个方法，第二次执行的时候，我们是执行已经生成好的代码，所以速度会非常快。你可以显示的调用 `llm.clear_impl_cache()` 清理掉函数缓存。\n\n## Stream 模式\n\n前面的例子都是一次性生成结果，但是有时候我们可能需要一个流式的输出，这个时候我们可能需要用底层一点的API来完成了：\n\n```python\nimport byzerllm\n\nllm = byzerllm.ByzerLLM.from_default_model(model=\"deepseek_chat\")\n\nv = llm.stream_chat_oai(model=\"deepseek_chat\",conversations=[{\n    \"role\":\"user\",\n    \"content\":\"你好，你是谁\",\n}],delta_mode=True)\n\nfor t in v:\n    print(t,flush=True)  \n\n# 你好\n# ！\n# 我\n# 是一个\n# 人工智能\n# 助手\n# ，\n# 旨在\n# 提供\n# 信息\n# 、\n# 解答\n# 问题....\n```\n\n如果你不想要流式输出，但是想用底层一点的API，你可以使用 `llm.chat_oai` 方法：\n\n```python\nimport byzerllm\n\nllm = byzerllm.ByzerLLM.from_default_model(model=\"deepseek_chat\")\n\nv = llm.chat_oai(model=\"deepseek_chat\",conversations=[{\n    \"role\":\"user\",\n    \"content\":\"你好，你是谁\",\n}])\n\nprint(v[0].output)\n## 你好！我是一个人工智能助手，旨在提供信息、解答问题和帮助用户解决问题。如果你有任何问题或需要帮助，请随时告诉我。\n```\n\n## Function Calling \n\nbyzerllm 可以不依赖模型自身就能提供 function calling 支持，我们来看个例子：\n\n\n```python\nfrom typing import List,Dict,Any,Annotated\nimport pydantic \nimport datetime\nfrom dateutil.relativedelta import relativedelta\n\ndef compute_date_range(count:Annotated[int,\"时间跨度，数值类型\"],\n                       unit:Annotated[str,\"时间单位，字符串类型\",{\"enum\":[\"day\",\"week\",\"month\",\"year\"]}])->List[str]:\n    '''\n    计算日期范围\n\n    Args:\n        count: 时间跨度，数值类型\n        unit: 时间单位，字符串类型，可选值为 day,week,month,year\n    '''        \n    now = datetime.datetime.now()\n    now_str = now.strftime(\"%Y-%m-%d %H:%M:%S\")\n    if unit == \"day\":\n        return [(now - relativedelta(days=count)).strftime(\"%Y-%m-%d %H:%M:%S\"),now_str]\n    elif unit == \"week\":\n        return [(now - relativedelta(weeks=count)).strftime(\"%Y-%m-%d %H:%M:%S\"),now_str]\n    elif unit == \"month\":\n        return [(now - relativedelta(months=count)).strftime(\"%Y-%m-%d %H:%M:%S\"),now_str]\n    elif unit == \"year\":\n        return [(now - relativedelta(years=count)).strftime(\"%Y-%m-%d %H:%M:%S\"),now_str]\n    return [\"\",\"\"]\n\ndef compute_now()->str:\n    '''\n    计算当前时间\n    '''\n    return datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n```\n\n我们定义了两个方法，一个是计算日期范围，一个是计算当前时间。\n\n现在我么可以来测试下，系统如何根据自然语言决定调用哪个方法：\n\n```python\nt = llm.chat_oai([{\n    \"content\":'''计算当前时间''',\n    \"role\":\"user\"    \n}],tools=[compute_date_range,compute_now],execute_tool=True)\n\nt[0].values\n\n## output: ['2024-06-14 15:18:02']\n```\n\n我们可以看到，他正确的选择了 compute_now 方法。\n\n接着我们再试一个：\n\n```python\nt = llm.chat_oai([{\n    \"content\":'''最近三个月趋势''',\n    \"role\":\"user\"    \n}],tools=[compute_date_range,compute_now],execute_tool=True)\n\nt[0].values\n\n## output: [['2024-03-14 15:19:13', '2024-06-14 15:19:13']]\n```\n\n模型正确的选择了 compute_date_range 方法。\n\n## 多模态\n\nbyerllm 也能很好的支持多模态的交互，而且统一了多模态大模型的接口，比如你可以用一样的方式使用 openai 或者 claude 的图片转文字能力， 或者一致的方式使用火山，azuer, openai的语音合成接口。\n\n### 图生文\n\n```python\nimport byzerllm\nfrom byzerllm.types import ImagePath\n\nvl_llm = byzerllm.ByzerLLM.from_default_model(\"gpt4o_mini_chat\")\n\n\n@byzerllm.prompt()\ndef what_in_image(image_path: ImagePath) -> str:\n    \"\"\"\n    {{ image_path }}\n    这个图片里有什么？\n    \"\"\"    \n\n\nv = what_in_image.with_llm(vl_llm).run(\n    ImagePath(value=\"/Users/allwefantasy/projects/byzer-llm/images/cat1.png\")\n)\nv\n## OUTPUT: 这张图片展示了多只可爱的猫咪，采用了艺术风格的绘画。猫咪们有不同的颜色和花纹，背景是浅棕色，上面还点缀着一些红色的花朵。整体画面给人一种温馨和谐的感觉\n```\n\n可以看到，我们只需要把 prompt 函数的图片地址入参使用 byzerllm.types.ImagePath里进行包装，就可以直接在 prompt 函数体里\n带上图片。\n\n或者你可以这样：\n\n```python\nimport byzerllm\n\nvl_llm = byzerllm.ByzerLLM.from_default_model(\"gpt4o_mini_chat\")\n\n\n@byzerllm.prompt()\ndef what_in_image(image_path: str) -> str:\n    \"\"\"\n    {{ image }}\n    这个图片里有什么？\n    \"\"\"\n    return {\"image\": byzerllm.Image.load_image_from_path(image_path)}\n\n\nv = what_in_image.with_llm(vl_llm).run(\n    \"/Users/allwefantasy/projects/byzer-llm/images/cat1.png\"\n)\nv\n```\n\n通过 `image_path` 参数，然后通过 `byzerllm.Image.load_image_from_path` 方法，转化为一个图片对象 image，最后在 prompt 函数体里\n使用 `{{ image }}` 引用这个图片对象。\n\n另外我们也是可以支持配置多张图片的。\n\n另外，我们也可以使用基础的 `llm.chat_oai` 方法来实现：\n\n```python\nimport byzerllm\nimport json\n\nvl_llm = byzerllm.ByzerLLM.from_default_model(\"gpt4o_mini_chat\")\nimage = byzerllm.Image.load_image_from_path(\n    \"/Users/allwefantasy/projects/byzer-llm/images/cat1.png\"\n)\nv = vl_llm.chat_oai(\n    conversations=[\n        {\n            \"role\": \"user\",\n            \"content\": json.dumps(\n                [{\"image\": image, \"text\": \"这个图片里有什么？\"}], ensure_ascii=False\n            ),\n        }\n    ]\n)\nv[0].output\n```\n\n还可以这么写：\n\n```python\nimport byzerllm\nimport json\n\nvl_llm = byzerllm.ByzerLLM.from_default_model(\"gpt4o_mini_chat\")\nimage = byzerllm.Image.load_image_from_path(\n    \"/Users/allwefantasy/projects/byzer-llm/images/cat1.png\"\n)\nv = vl_llm.chat_oai(\n    conversations=[\n        {\n            \"role\": \"user\",\n            \"content\": json.dumps(\n                [\n                    {\n                        \"type\": \"image_url\",\n                        \"image_url\": {\"url\": image, \"detail\": \"high\"},\n                    },\n                    {\"text\": \"这个图片里有什么？\", \"type\": \"text\"},\n                ],\n                ensure_ascii=False,\n            ),\n        }\n    ]\n)\nv[0].output\n```\n\n### 语音合成\n\n这里以 openai 的 tts 为例：\n\n```bash\nbyzerllm deploy --pretrained_model_type saas/openai \\\n--cpus_per_worker 0.001 \\\n--gpus_per_worker 0 \\\n--num_workers 1 \\\n--infer_params saas.api_key=${MODEL_OPENAI_TOKEN} saas.model=tts-1 \\\n--model openai_tts\n```\n\n此外，byzerllm 支持 azure,火山引擎等 tts 语音合成引擎。\n\n接着你可以这么用：\n\n```python\nimport byzerllm\nimport base64\nimport json\n\nllm = byzerllm.ByzerLLM.from_default_model(\"openai_tts\")\n\n\nt = llm.chat_oai(conversations=[{\n    \"role\":\"user\",\n    \"content\": json.dumps({\n        \"input\":\"hello, open_tts\",\n        \"voice\": \"alloy\",\n        \"response_format\": \"mp3\"\n    },ensure_ascii=False)\n}])\n\nwith open(\"voice.mp3\",\"wb\") as f:\n    f.write(base64.b64decode(t[0].output))\n```\n\ntts 模型生成没有prompt函数可以用，你需要直接使用 chat_oai。\n\n\n### 语音识别\n\n这里以 openai 的 whisper-1 为例：\n\n```bash\nbyzerllm deploy --pretrained_model_type saas/openai \\\n--cpus_per_worker 0.001 \\\n--gpus_per_worker 0 \\\n--num_workers 1 \\\n--worker_concurrency 10 \\\n--infer_params saas.model=whisper-1 saas.api_key=${MODEL_OPENAI_TOKEN} \\\n--model speech_to_text\n```\n\n语音识别的使用方式和图生文类似，我们可以直接在 prompt 函数体里带上音频文件。\n\n```python\nimport byzerllm\nimport json\nimport base64\nfrom byzerllm.types import AudioPath\n\nllm = byzerllm.ByzerLLM.from_default_model(\"speech_to_text\")\n\naudio_file = \"/Users/allwefantasy/videos/output_audio.mp3\"\n\n@byzerllm.prompt(llm=llm)\ndef audio_to_text(audio_file: AudioPath):\n    \"\"\"\n    {{ audio_file }}\n    \"\"\"\n\nv = audio_to_text(AudioPath(value=audio_file))\njson.loads(v)\n```\n输出的数据格式略微复杂：\n\n```\n{'text': 'In the last chapter, you and I started to step through the internal workings of a transformer. This is one of the key pieces of technology inside large language models, and a lot of other tools in the modern wave of AI.',\n 'task': 'transcribe',\n 'language': 'english',\n 'duration': 10.0,\n 'segments': [{'id': 0,\n   'seek': 0,\n   'start': 0.0,\n   'end': 4.78000020980835,\n   'text': ' In the last chapter, you and I started to step through the internal workings of a transformer.',\n   'tokens': [50364,\n    682,\n    264,\n    1036,\n    7187,\n    11,\n    291,\n    293,\n    286,\n    1409,\n    281,\n    1823,\n    807,\n    264,\n    6920,\n    589,\n    1109,\n    295,\n    257,\n    31782,\n    13,\n    50586],\n   'temperature': 0.0,\n   'avg_logprob': -0.28872039914131165,\n   'compression_ratio': 1.4220778942108154,\n   'no_speech_prob': 0.016033057123422623},\n  ....\n  {'id': 2,\n   'seek': 0,\n   'start': 8.579999923706055,\n   'end': 9.979999542236328,\n   'text': ' and a lot of other tools in the modern wave of AI.',\n   'tokens': [50759,\n    293,\n    257,\n    688,\n    295,\n    661,\n    3873,\n    294,\n    264,\n    4363,\n    5772,\n    295,\n    7318,\n    13,\n    50867],\n   'temperature': 0.0,\n   'avg_logprob': -0.28872039914131165,\n   'compression_ratio': 1.4220778942108154,\n   'no_speech_prob': 0.016033057123422623}],\n 'words': [{'word': 'In', 'start': 0.0, 'end': 0.18000000715255737},\n  {'word': 'the', 'start': 0.18000000715255737, 'end': 0.23999999463558197},\n  {'word': 'last', 'start': 0.23999999463558197, 'end': 0.5400000214576721},\n  {'word': 'chapter', 'start': 0.5400000214576721, 'end': 0.800000011920929},\n  ....\n  {'word': 'AI', 'start': 9.920000076293945, 'end': 9.979999542236328}]}\n```\n\n会输出每一句话以及每一个字所在的起始时间和截止时间。你可以根据需要来使用。\n\n\n### 文生图\n\n文生图和语音合成类似，首先要启动合适的模型,以openai 的 dall-e-3 为例：\n\n```bash\nbyzerllm deploy --pretrained_model_type saas/openai \\\n--cpus_per_worker 0.001 \\\n--gpus_per_worker 0 \\\n--num_workers 1 \\\n--infer_params saas.api_key=${MODEL_OPENAI_TOKEN} saas.model=dall-e-3 \\\n--model openai_image_gen\n```\n\n启动模型后，只需要记住几个模板参数即可使用，这里直接使用 chat_oai 方法来使用：\n\n```python\n\nimport byzerllm\nimport json\nimport base64\n\nllm = byzerllm.ByzerLLM.from_default_model(\"openai_image_gen\")\nt = llm.chat_oai(conversations=[{\n    \"role\":\"user\",\n    \"content\": json.dumps({\n        \"input\":\"a white siamese cat\",\n        \"size\": \"1024x1024\",\n        \"quality\": \"standard\"\n    },ensure_ascii=False)\n}])\n\nwith open(\"output1.jpg\",\"wb\") as f:\n    f.write(base64.b64decode(t[0].output))\n\n\nimport matplotlib.pyplot as plt\n\nimage_path = \"output1.jpg\"\nimage = plt.imread(image_path)\n\nplt.imshow(image)\nplt.axis('off')\nplt.show()\n```\n\n## Prompt 函数的流式输出\n\nbyzerllm 底层支持流式输出，非 prompt 函数的用法是这样的：\n\n```python\nimport byzerllm\n\nllm = byzerllm.ByzerLLM.from_default_model(\"deepseek_chat\")\n\nv = llm.stream_chat_oai(conversations=[{\n    \"role\":\"user\",\n    \"content\":\"讲一个100字的故事\"\n}])\n\nfor s  in v:\n    print(s[0], end=\"\")\n```\n\n如果你像用 prompt 函数，可以这么用：\n\n\n```python\nimport byzerllm\nimport json\nimport base64\nfrom typing import Generator\n\nllm = byzerllm.ByzerLLM.from_default_model(\"deepseek_chat\")\n\n@byzerllm.prompt()\ndef tell_story() -> Generator[str, None, None]:\n    '''\n    给我讲一个一百多字的故事\n    '''\n\nv = tell_story.with_llm(llm).run()    \nfor i in v:\n    print(i, end=\"\")\n```\n\n可以看到，和普通的 prompt 函数的区别在于，返回值是一个生成器，然后你可以通过 for 循环来获取结果。\n\n## 向量化模型\n\nbyzerllm 支持向量化模型,你可以这样启动一个本地的模型：\n\n```bash\n!byzerllm deploy --pretrained_model_type custom/bge \\\n--cpus_per_worker 0.001 \\\n--gpus_per_worker 0 \\\n--worker_concurrency 10 \\\n--model_path /home/winubuntu/.auto-coder/storage/models/AI-ModelScope/bge-large-zh \\\n--infer_backend transformers \\\n--num_workers 1 \\\n--model emb\n```\n\n注意两个参数:\n\n1. --infer_backend transformers: 表示使用 transformers 作为推理后端。\n2. --model_path: 表示模型的路径。\n\n也可以启动一个 SaaS 的emb模型,比如 qwen 的 emb 模型：\n\n```bash\nbyzerllm deploy --pretrained_model_type saas/qianwen \\\n--cpus_per_worker 0.001 \\\n--gpus_per_worker 0 \\\n--num_workers 2 \\\n--infer_params saas.api_key=${MODEL_QIANWEN_TOKEN}  saas.model=text-embedding-v2 \\\n--model qianwen_emb\n```\n\n或者 openai 的 emb 模型：\n\n```bash\nbyzerllm deploy --pretrained_model_type saas/openai \\\n--cpus_per_worker 0.001 \\\n--gpus_per_worker 0 \\\n--num_workers 1 \\\n--worker_concurrency 10 \\\n--infer_params saas.api_key=${MODEL_OPENAI_TOKEN} saas.model=text-embedding-3-small \\\n--model gpt_emb\n```\nSaaS 模型无需配置 `--infer_backend` 参数。\n\n无论是本地模型还是 SaaS 模型，我们都可以这样使用：\n\n```python\nimport byzerllm\nllm = byzerllm.ByzerLLM.from_default_model(\"deepseek_chat\")\nllm.setup_default_emb_model_name(\"emb\")\nllm.emb_query(\"你好\")\n```\n\n如果你配置 byzerllm 中的 Storage 使用，比如你这样启动了存储：\n\n```bash\nbyzerllm storage start --enable_emb\n```\n\n那么需要这么使用：\n\n```python\nfrom byzerllm.apps.byzer_storage.simple_api import ByzerStorage, DataType, FieldOption,SortOption\nstorage = ByzerStorage(\"byzerai_store\", \"memory\", \"memory\")\nstorage.emb(\"你好\")\n```\n\n## 一些辅助工具\n\n当调用 prompt 函数返回字符串的时候，如果想从里面抽取代码，可以使用如下方式：\n\n```python\nfrom byzerllm.utils.client import code_utils\ntext_with_markdown = '''\n```shell\nls -l\n```\n'''\ncode_blocks = code_utils.extract_code(text_with_markdown)\nfor code_block in code_blocks:\n    if code_block[0] == \"shell\":\n        print(code_block[1])\n##output: ls -l        \n```\n\nTagExtractor 工具用于对任意 `<_tag_></_tag_>` 标签对的抽取，下面是一个使用示例：\n\n```python\nfrom byzerllm.apps.utils import TagExtractor\n\nextractor = TagExtractor('''\n大家好\n<_image_>data:image/jpeg;base64,xxxxxx</_image_>\n                         大家好\n<_image_>data:image/jpeg;base64,xxxxxx2</_image_>\n''')\n\nv = extractor.extract()\nprint(v.content[0].content)\nprint(v.content[1].content)\n```\n输出为:\n\n```\ndata:image/jpeg;base64,xxxxxx\ndata:image/jpeg;base64,xxxxxx2\n```\n\n我们成功的将 <_image_></_image_> 标签对里的内容抽取出来了。\n\n\n## 注意事项\n\n1. prompt函数方法体返回只能是dict，实际的返回类型和方法签名可以不一样，但是方法体返回只能是dict。\n2. 大部分情况prompt函数体为空，如果一定要有方法体，可以返回一个空字典。\n3. 调用prompt方法的时候，如果在@byzerllm.prompt()里没有指定llm对象，那么需要在调用的时候通过with_llm方法指定llm对象。\n\n===========================\n\n# Byzer Storage: 最易用的AI存储引擎\n\nByzer Storage是一个为AI应用设计的高性能存储引擎,它提供了简单易用的API,支持向量搜索、全文检索以及结构化查询。本文将详细介绍Byzer Storage的使用方法和主要特性。\n\n## 0. 安装和启动\n\n```bash\npip install byzerllm\nbyzerllm storage start\n```\n\nThat's it! Byzer Storage已经安装并启动成功,现在我们可以开始使用它了。默认会启动一个 byzerai_store 的集群。\n\n注意，如果你是这样启动的：\n\n```bash\nbyzerllm storage start --enable_emb\n```\n\n那么会自动启动一个 emb 模型，名字就叫 emb， ByzerStorage 会自动使用该模型，无需做任何其他配置。\n\n## 1. 初始化\n\n创建一个 ByzerStorage 对象，链接 byzerai_store 集群，并且指定数据库和表名（可以不存在）。\n\n```python\nfrom byzerllm.apps.byzer_storage.simple_api import ByzerStorage, DataType, FieldOption, SortOption\n\nstorage = ByzerStorage(\"byzerai_store\", \"my_database1\", \"my_table4s\")\n```\n\n\n## 2. 创建库表（可选）\n\nByzer Storage使用Schema来定义数据结构。我们可以使用SchemaBuilder来构建Schema:\n\n```python\n_ = (\n    storage.schema_builder()\n    .add_field(\"_id\", DataType.STRING)\n    .add_field(\"name\", DataType.STRING)\n    .add_field(\"content\", DataType.STRING, [FieldOption.ANALYZE])\n    .add_field(\"raw_content\", DataType.STRING, [FieldOption.NO_INDEX])    \n    .add_array_field(\"summary\", DataType.FLOAT)    \n    .add_field(\"created_time\", DataType.LONG, [FieldOption.SORT])    \n    .execute()\n)\n```\n\n这个Schema定义了以下字段:\n- `_id`: 字符串类型的主键\n- `name`: 字符串类型,可用于过滤条件\n- `content`: 字符串类型,带有ANALYZE选项,用于全文搜索\n- `raw_content`: 字符串类型,带有NO_INDEX选项,不会被索引\n- `summary`: 浮点数组类型,用于存储向量\n- `created_time`: 长整型,带有SORT选项,可用于排序\n\n需要注意的是：\n\n1. 如果一个字段带有ANALYZE选项,则该字段会被分词,并且可以用于全文搜索，但是就无法返回原始的文本了。所以你需要添加一个新字段专门用来存储原文，比如在我们这个例子里，我们新增了 raw_content 字段，并且显示的指定了 NO_INDEX 选项，这样就不会被索引，也就不会被分词，可以后续被检索后用来获取原始文本。\n2. 对于需要作为向量检索和存储的字段，需要指定为数组类型，比如我们这个例子里的 summary 字段。\n3. 如果你需要拿到向量字段的原始文本，那么你也需要添加一个新字段专门用来存储原文，就像我们这个例子里的 raw_content 字段一样。\n\n\n## 3. 写入数据\n\n准备数据并使用WriteBuilder写入Storage:\n\n```python\ndata = [\n    {\"_id\": \"1\", \"name\": \"Hello\", \"content\": \"Hello, world!\", \"raw_content\": \"Hello, world!\", \"summary\": \"hello world\", \"created_time\": 1612137600},\n    {\"_id\": \"2\", \"name\": \"Byzer\", \"content\": \"Byzer, world!\", \"raw_content\": \"Byzer, world!\", \"summary\": \"byzer\", \"created_time\": 1612137601},\n    {\"_id\": \"3\", \"name\": \"AI\", \"content\": \"AI, world!\", \"raw_content\": \"AI, world!\", \"summary\": \"AI\", \"created_time\": 16121376002},\n    {\"_id\": \"4\", \"name\": \"ByzerAI\", \"content\": \"ByzerAI, world!\", \"raw_content\": \"ByzerAI, world!\", \"summary\": \"ByzerAi\", \"created_time\": 16121376003},\n]\n\nstorage.write_builder().add_items(data, vector_fields=[\"summary\"], search_fields=[\"content\"]).execute()\nstorage.commit()\n```\n\n这里我们使用`add_items`方法批量添加数据,并指定了`summary`为向量字段,`content`为搜索字段。最后调用`commit()`来确保数据被持久化。\n\n\n从上面我们要写入到 byzer storage 的数据我们可以看到如下几个特点：\n\n1. 需要包含我们之前定义的 Schema中罗列的所有的字段，同时需要指定哪些是向量字段，哪些是检索字段。\n2. 向量和检索不能是同一个字段。\n3. 对于向量，检索字段，我们给到 write_builder 的都是文本，ByzerStorage 会根据 Schema 的定义自动将其转换为向量，检索字段需要的格式。\n\n## 4. 查询数据\n\nByzer Storage支持多种查询方式,包括向量搜索、全文检索、过滤和排序。\n\n### 4.1 向量搜索 + 全文检索\n\n```python\nquery = storage.query_builder()\nquery.set_vector_query(\"ByzerAI\", fields=[\"summary\"])\nresults = query.set_search_query(\"Hello\", fields=[\"content\"]).execute()\nprint(results)\n```\n\n这个查询结合了向量搜索和全文检索,它会在`summary`字段中搜索与\"ByzerAI\"相似的向量,同时在`content`字段中搜索包含\"Hello\"的文档。\n\n### 4.2 过滤 + 向量搜索 + 全文检索\n\n```python\nquery = storage.query_builder()\nquery.and_filter().add_condition(\"name\", \"AI\").build()\nquery.set_vector_query(\"ByzerAI\", fields=\"summary\")\nresults = query.set_search_query(\"Hello\", fields=[\"content\"]).execute()\nprint(results)\n```\n\n这个查询首先过滤`name`字段等于\"AI\"的文档,然后在结果中进行向量搜索和全文检索。\n\n### 4.3 过滤 + 排序\n\n```python\nquery = storage.query_builder()\nquery.and_filter().add_condition(\"name\", \"AI\").build().sort(\"created_time\", SortOption.DESC)\nresults = query.execute()\nprint(results)\n```\n\n这个查询过滤`name`字段等于\"AI\"的文档,然后按`created_time`字段降序排序。\n\n## 5. 删除数据\n\n### 5.1 根据ID删除\n\n```python\nstorage.delete_by_ids([\"3\"])\n\nquery = storage.query_builder()\nquery.and_filter().add_condition(\"name\", \"AI\").build()\nresults = query.execute()\nprint(results)\n```\n\n这里我们删除了ID为\"3\"的文档,然后查询验证删除结果。\n\n### 5.2 删除整个表\n\n```python\nstorage.drop()\n```\n\n这个操作会删除整个表及其所有数据,请谨慎使用。\n\n## 结论\n\nByzer Storage提供了一套简洁而强大的API,能够轻松实现向量搜索、全文检索、结构化查询等功能。它的设计非常适合AI应用场景,可以有效地存储和检索各种类型的数据。通过本文的介绍,相信读者已经对Byzer Storage有了基本的了解,并能够开始在自己的项目中使用这个强大的存储引擎。\n", "tag": ""}], "modify_time": 1725169089.4229312}
